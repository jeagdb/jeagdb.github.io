<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>React</title><meta name="description" content="Jeagdb website"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/logo512.png"/><meta name="next-head-count" content="5"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-096e6c2702c5645c.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-25c9a70a89fc94c8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-83b36c5ab3bef3ff.js" defer=""></script><script src="/_next/static/chunks/29107295-8619d3a1a46e5850.js" defer=""></script><script src="/_next/static/chunks/c16184b3-0454fdc66dc7403d.js" defer=""></script><script src="/_next/static/chunks/476-d421188f47b61f82.js" defer=""></script><script src="/_next/static/chunks/603-b89c99a34b923424.js" defer=""></script><script src="/_next/static/chunks/pages/content/%5Bid%5D-8d46ebffd3f81e29.js" defer=""></script><script src="/_next/static/nipmgq2y6MMnOk2Zrye-t/_buildManifest.js" defer=""></script><script src="/_next/static/nipmgq2y6MMnOk2Zrye-t/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.11">*,*::before,*::after{box-sizing:border-box;}/*!sc*/
#__next{height:100%;width:100%;}/*!sc*/
html{height:100%;margin:0;}/*!sc*/
body{margin:0;height:100%;color:white;font-family:'Roboto',sans-serif;background-image:black;}/*!sc*/
body *::-webkit-scrollbar{width:4px;}/*!sc*/
body *::-webkit-scrollbar-thumb{background:white;-webkit-transition:.5s;transition:.5s;}/*!sc*/
a{-webkit-text-decoration:none;text-decoration:none;color:inherit;}/*!sc*/
a:hover{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
img{max-width:100%;}/*!sc*/
pre{background:grey;padding:2px 4px;border-radius:10px;}/*!sc*/
code{background:grey;padding:0px 4px;border-radius:10px;white-space:pre-wrap;}/*!sc*/
data-styled.g1[id="sc-global-bTRaNr1"]{content:"sc-global-bTRaNr1,"}/*!sc*/
.jAHpBr{position:absolute;top:0;width:24px;height:24px;top:8px;left:12px;padding:4px;cursor:pointer;}/*!sc*/
data-styled.g2[id="HomeButton-sc-1snf18r-0"]{content:"jAHpBr,"}/*!sc*/
.byDFHs{margin-left:16px;font-size:18px;}/*!sc*/
data-styled.g33[id="Folder__Block-sc-1b0px8i-0"]{content:"byDFHs,"}/*!sc*/
.hAjrvM{cursor:pointer;font-size:18px;}/*!sc*/
@media (max-width:769px){.hAjrvM{font-size:22px;}}/*!sc*/
data-styled.g34[id="Folder__FolderTitle-sc-1b0px8i-1"]{content:"hAjrvM,"}/*!sc*/
@media (max-width:769px){.dJFKXp{display:none;}}/*!sc*/
data-styled.g35[id="Tree__Container-sc-1jgaow7-0"]{content:"dJFKXp,"}/*!sc*/
.dxtDKA{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-self:start;-ms-flex-item-align:start;align-self:start;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:auto;padding:16px;min-width:300px;max-height:500px;}/*!sc*/
data-styled.g36[id="Tree__Arborescence-sc-1jgaow7-1"]{content:"dxtDKA,"}/*!sc*/
.hVrUNP{background:linear-gradient(20deg,#FBEEC1,#659DBD,#DAAD86,#8D8741);background-size:150% 150%;-webkit-animation-name:flPffe;animation-name:flPffe;-webkit-animation-duration:40s;animation-duration:40s;-webkit-animation-timing-function:ease;animation-timing-function:ease;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;}/*!sc*/
data-styled.g37[id="GradientBg-sc-1qytzh1-0"]{content:"hVrUNP,"}/*!sc*/
.fkWwhY{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;border:1px solid #fff;padding:0px 8px;max-width:100%;height:80%;}/*!sc*/
@media (max-width:769px){.fkWwhY{border:none;padding:0px 0px;margin-top:18px;font-size:16px;display:block;}}/*!sc*/
data-styled.g38[id="MdVisualizer__Page-sc-1hka3jl-0"]{content:"fkWwhY,"}/*!sc*/
.kixegV{position:absolute;top:0;right:0;border:1px solid #fff;border-top:none;border-right:none;padding:2px 16px;color:#fff;background:#659DBD;}/*!sc*/
@media (min-width:769px){.kixegV{font-size:17px;}}/*!sc*/
data-styled.g39[id="MdVisualizer__Title-sc-1hka3jl-1"]{content:"kixegV,"}/*!sc*/
.jToKSj{padding:0px 8px;max-height:550px;overflow-y:scroll;}/*!sc*/
data-styled.g40[id="MdVisualizer__Content-sc-1hka3jl-2"]{content:"jToKSj,"}/*!sc*/
.kicYxY{position:absolute;top:8px;left:12px;padding:4px;cursor:pointer;color:white;width:26px;}/*!sc*/
@media (min-width:769px){.kicYxY{display:none;}}/*!sc*/
data-styled.g41[id="MdVisualizer__BackButton-sc-1hka3jl-3"]{content:"kicYxY,"}/*!sc*/
.gdxHoY{height:100%;max-width:100%;padding:24px 32px;}/*!sc*/
data-styled.g42[id="ContentLayout__Page-sc-1t6gg0-0"]{content:"gdxHoY,"}/*!sc*/
.gRnpIg{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:16px;max-width:100%;}/*!sc*/
@media (max-width:769px){.gRnpIg{-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}}/*!sc*/
data-styled.g43[id="ContentLayout__Inline-sc-1t6gg0-1"]{content:"gRnpIg,"}/*!sc*/
@-webkit-keyframes flPffe{0%{background-position:0% 100%;}50%{background-position:100% 0%;}100%{background-position:0% 100%;}}/*!sc*/
@keyframes flPffe{0%{background-position:0% 100%;}50%{background-position:100% 0%;}100%{background-position:0% 100%;}}/*!sc*/
data-styled.g44[id="sc-keyframes-flPffe"]{content:"flPffe,"}/*!sc*/
</style></head><body><div id="__next"><div class="GradientBg-sc-1qytzh1-0 ContentLayout__Page-sc-1t6gg0-0 hVrUNP gdxHoY"><div class="ContentLayout__Inline-sc-1t6gg0-1 gRnpIg"><div class="Tree__Container-sc-1jgaow7-0 dJFKXp"><a href="/"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="house" class="svg-inline--fa fa-house HomeButton-sc-1snf18r-0 jAHpBr" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" color="white"><path fill="currentColor" d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg></a><div class="Tree__Arborescence-sc-1jgaow7-1 dxtDKA"><div class="Folder__Block-sc-1b0px8i-0 byDFHs"><div class="Folder__FolderTitle-sc-1b0px8i-1 hAjrvM">basics<!-- --> <!-- -->+</div></div><div class="Folder__Block-sc-1b0px8i-0 byDFHs"><div class="Folder__FolderTitle-sc-1b0px8i-1 hAjrvM">frontend<!-- --> <!-- -->+</div></div><div class="Folder__Block-sc-1b0px8i-0 byDFHs"><div class="Folder__FolderTitle-sc-1b0px8i-1 hAjrvM">projets<!-- --> <!-- -->+</div></div></div></div><div class="MdVisualizer__Page-sc-1hka3jl-0 fkWwhY"><div class="MdVisualizer__Title-sc-1hka3jl-1 kixegV">React</div><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="arrow-left" class="svg-inline--fa fa-arrow-left MdVisualizer__BackButton-sc-1hka3jl-3 kicYxY" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" color="white" font-size="10"><path fill="currentColor" d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg><div class="MdVisualizer__Content-sc-1hka3jl-2 jToKSj"><div><p><strong>React</strong> est une bibliothèque JavaScript pour la construction d’interfaces utilisateur (UI).</p>
<hr>
<h2>JSX</h2>
<p>C’est une extension syntaxique de JavaScript qui permet de décrire à quoi devrait ressembler l’interface utilisateur. C’est un peu un mix entre un langage de balisage et de javascript.</p>
<p>JSX produit des « éléments » React qui seront ensuite retranscrit dans le DOM.</p>
<p>Le fonctionnement d’une UI conditionnera toujours les logiques de rendu, de la gestion des événements à la préparation des données pour l’affichage, en passant par l’évolution de l’état au fil du temps. React a choisi d’assumer pleinement cet état de fait.</p>
<p>Au lieu de séparer artificiellement les <em>technologies</em> en mettant le balisage et la logique dans des fichiers séparés, React sépare les <em>préoccupations (ou responsabilités)</em> via des unités faiblement couplées appelées « composants », qui contiennent les deux.</p>
<p>React n’oblige pas à utiliser JSX, mais la plupart des gens y trouvent une aide visuelle quand ils manipulent l’interface utilisateur dans le code JavaScript. Ça permet aussi à React de produire des messages d’erreurs et d’avertissements plus utiles.</p>
<pre><code>const name = 'monde';

// Il est possible de mettre n'importe quelle expression js dans les accolades
const element = &#x3C;h1>Bonjour, {name}&#x3C;/h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
</code></pre>
<p>Après la compilation, les expressions JSX deviennent de simples appels de fonctions js, dont l’évaluation renvoie des objets js.</p>
<p>Ça signifie que vous pouvez utiliser JSX à l’intérieur d’instructions <code>if</code> ou de boucles <code>for</code>, l’affecter à des variables, l’accepter en tant qu’argument, et le renvoyer depuis des fonctions :</p>
<pre><code>function getGreeting(user) {
  if (user) {
    return &#x3C;h1>Bonjour, {formatName(user)} !&#x3C;/h1>;  
	}

  return &#x3C;h1>Bonjour, monde.&#x3C;/h1>;}
</code></pre>
<p>Bon à savoir: Dans la mesure où JSX est plus proche de JavaScript que de HTML, React DOM utilise la casse <code>camelCase</code>comme convention de nommage des propriétés, au lieu des noms d’attributs HTML. Donc pour les attributs, on aura className plutôt que class, etc,…</p>
<h3>Sécurité</h3>
<p>Par défaut, React DOM échappe toutes les valeurs intégrées avec JSX avant d’en faire le rendu. ****</p>
<p>Il garantit ainsi que vous ne risquez jamais d’injecter quoi que ce soit d’autre que ce vous avez explicitement écrit dans votre application. Tout est converti en chaîne de caractères avant de produire le rendu. Ça aide à éviter les attaques XSS.</p>
<h3>JSX représente des objets</h3>
<pre><code>const element = (
  &#x3C;h1 className="greeting">
    Bonjour, monde !
  &#x3C;/h1>);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Bonjour, monde !'
);

// React.createElement() effectue quelques vérifications pour vous aider
// à écrire un code sans bug, mais pour l’essentiel il crée un objet qui 
// ressemble à ceci :

// Remarque : cette structure est simplifiée
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Bonjour, monde !'
  }
};
</code></pre>
<hr>
<h2>Rendu des éléments</h2>
<p>Un élément décrit ce que vous voulez voir à l’écran :</p>
<pre><code>const element = &#x3C;h1>Bonjour, monde&#x3C;/h1>;
</code></pre>
<p>Contrairement aux éléments DOM d’un navigateur, les éléments React sont de simples objets peu coûteux à créer. React DOM se charge de mettre à jour le DOM afin qu’il corresponde aux éléments React.</p>
<p>Nous parlons de nœud DOM « racine » car tout ce qu’il contient sera géré par React DOM.</p>
<pre><code>&#x3C;div id="root">&#x3C;/div>
</code></pre>
<p>Les applications dévéloppées uniquement avec React ont généralement un seul nœud DOM racine. Si vous intégrez React dans une application existante, vous pouvez avoir autant de nœuds DOM racines isolés que vous le souhaitez.</p>
<p>Pour faire le rendu d’un élément React dans un nœud DOM racine, passez les deux à la méthode <code>[ReactDOM.render()](https://fr.reactjs.org/docs/react-dom.html#render)</code> :</p>
<pre><code>const element = &#x3C;h1>Bonjour, monde&#x3C;/h1>;
ReactDOM.render(element, document.getElementById('root'));
</code></pre>
<p>Les éléments React sont <strong>immuables</strong>.</p>
<p>Une fois votre élément créé, vous ne pouvez plus modifier ses enfants ou ses attributs. Un élément est comme une image d’un film à un instant T : il représente l’interface utilisateur à un point précis dans le temps.</p>
<pre><code>function tick() {
  const element = (
    &#x3C;div>
      &#x3C;h1>Bonjour, monde !&#x3C;/h1>
      &#x3C;h2>Il est {new Date().toLocaleTimeString()}.&#x3C;/h2>
    &#x3C;/div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
// À chaque seconde, nous appellons ReactDOM.render() depuis une fonction de rappel 
// passée à setInterval().
</code></pre>
<p>React DOM compare l’élément et ses enfants avec la version précédente, et applique uniquement les mises à jour DOM nécessaires pour refléter l’état voulu.</p>
<hr>
<h2>Composants et props</h2>
<p>Les composants permettent de découper l’interface utilisateur en éléments indépendants et réutilisables, permettant ainsi de considérer chaque élément de manière isolée.</p>
<p>Conceptuellement, les composants sont comme des fonctions js. Ils acceptent des entrées quelconques (appelées « props ») et renvoient des éléments React décrivant ce qui doit apparaître à l’écran.</p>
<pre><code>const Welcome = (props) => {
  return (
		&#x3C;h1>Bonjour, {props.name}&#x3C;/h1>
	);
}
</code></pre>
<p>Cette fonction est un composant React valide car elle accepte un seul argument « props » (qui signifie « propriétés ») contenant des données, et renvoie un élément React. Nous appelons de tels composants des « fonctions composants », car ce sont littéralement des fonctions js.</p>
<p>Jusqu’ici, nous n’avons rencontré que des éléments React représentant des balises DOM :</p>
<pre><code>const element = &#x3C;div />;
</code></pre>
<p>Mais ces éléments peuvent également représenter des composants définis par l’utilisateur :</p>
<pre><code>const element = &#x3C;Welcome name="Sara" />;
</code></pre>
<h3>Props</h3>
<p>Un composant ne doit jamais modifier ses propres props.</p>
<p><strong>Tout composant React doit agir comme une fonction pure vis-à-vis de ses props.</strong></p>
<p>Bien entendu, les interfaces utilisateurs des applications sont dynamiques et évoluent dans le temps, on introduit donc le concept d’ <strong>état local.</strong></p>
<p>L’état local permet aux composants React de modifier leur sortie au fil du temps en fonction des actions de l’utilisateur, des réponses réseau et de n’importe quoi d’autre, mais sans enfreindre cette règle.</p>
<hr>
<h2>Gérer les événements</h2>
<p>La gestion des événements pour les éléments React est très similaire à celle des éléments du DOM.</p>
<pre><code>const ActionLink = () => {
// e est un événement synthétique
  const handleClick = (e) => {
    e.preventDefault();
    console.log('Le lien a été cliqué.');
  }

  return (
    &#x3C;a href="#" onClick={handleClick}>
      Clique ici
    &#x3C;/a>
  );
}
</code></pre>
<p>Lorsque vous utilisez React, vous n’avez généralement pas besoin d’appeler la méthode <code>addEventListener</code> pour ajouter des écouteurs d’événements.</p>
<hr>
<h2>Composition ?</h2>
<p>React fournit un puissant modèle de composition, aussi il est recommandé d’utiliser la composition plutôt que l’héritage pour réutiliser du code entre les composants.</p>
<h3>Délégation de contenu</h3>
<p>Certains composants ne connaissent pas leurs enfants à l’avance. C’est particulièrement courant pour des composants comme <code>Sidebar</code> ou <code>Dialog</code>, qui représentent des blocs génériques.</p>
<p>Pour de tels composants, nous vous conseillons d’utiliser la prop spéciale <code>children</code></p>
<p>exemple:</p>
<pre><code>function FancyBorder(props) {
  return (
    &#x3C;div>
      {props.children}
    &#x3C;/div>
  );
}
// Ça permet aux autres composants de leur passer des enfants quelconques
function WelcomeDialog() {
  return (
    &#x3C;FancyBorder>
      &#x3C;h1>Bienvenue&#x3C;/h1>
    &#x3C;/FancyBorder>
  );
}
</code></pre>
<h3>Spécialisation</h3>
<p>Parfois, nous voyons les composants comme des « cas particuliers » d’autres composants. Par exemple, nous pourrions dire que <code>WelcomeDialog</code>est un cas particulier de <code>Dialog</code>.
Avec React, on réalise ça avec la composition ; un composant plus « spécialisé » utilise un composant plus « générique » et le configure grâce aux props.</p>
<p>Exemple:</p>
<pre><code>function WelcomeDialog() {
  return (
		&#x3C;>
			&#x3C;h1>Hello !&#x3C;/h1>
	    &#x3C;Dialog
	      title="Bienvenue"
	      message="Merci de visiter notre vaisseau spatial !" />
		&#x3C;/>
  );
}
</code></pre>
<p>Les props et la composition donnent toute la flexibilité pour personnaliser l’apparence et le comportement d’un composant de manière explicite et sûre. (un composant peut accepter tout type de props, y compris des valeurs primitives, des éléments React et des fonctions.)</p>
<hr>
<h2>Découpage dynamique de code</h2>
<h3>Bundling</h3>
<p>La plupart des applications React empaquetteront leur fichiers au moyen d’outils tels que Webpack, Rollup ou Browserify. L’empaquetage <em>(bundling)</em> consiste à suivre le graphe des importations dans les fichiers, et à les regrouper au sein d’un même fichier : un bundle. Ce bundle peut ensuite être inclus dans une page web pour charger une application entière d’un seul coup.****</p>
<p>Les bundles c’est génial, mais au fur et à mesure qu’une application grandit, son bundle va grossir aussi. Surtout si de grosses bibliothèques tierces y sont intégrées.</p>
<p>Il est important de garder un œil sur le code qu’on intègre dans un bundle pour éviter de le rendre si lourd que le chargement de l’ application prendrait beaucoup de temps.</p>
<p>Pour éviter de se retrouver avec un bundle trop volumineux, il est bon d’anticiper les problèmes et de commencer à fractionner le bundle. Le découpage dynamique de code est une fonctionnalité prise en charge par des empaqueteurs, qui permet de créer plusieurs bundles pouvant être chargés dynamiquement au moment de l’exécution.</p>
<p>Fractionner une application peut aider à charger à la demande <em>(lazy-load)</em> les parties qui sont nécessaires pour l’utilisateur à un moment donné, ce qui peut améliorer considérablement les performances de l’application. Bien que la quantité de code de l’application n’est pas été diminuée, on évite de charger du code dont l’utilisateur n’aura peut-être jamais besoin, et on réduit la quantité de code nécessaire au chargement initial.****</p>
<h3>Import dynamique</h3>
<pre><code>// AVANT
import { add } from './math';

console.log(add(16, 26));

// APRES
import("./math").then(math => {
  console.log(math.add(16, 26));
});
</code></pre>
<h3>React.lazy</h3>
<p>Remarque: <code>React.lazy</code>et <code>Suspense</code> ne sont pas encore disponibles pour le rendu côté serveur.</p>
<p>La fonction React.lazy permet d’afficher un composant importé dynamiquement comme n’importe quel autre composant.</p>
<pre><code>// AVANT
import OtherComponent from './OtherComponent'
// APRES
const OtherComponent = React.lazy(() => import('./OtherComponent'))
</code></pre>
<p>Ça chargera automatiquement le bundle contenant le composant OtherComponent quand celui-ci sera rendu pour la première fois.</p>
<p>React.lazy prend une fonction qui doit appeler un import() dynamique. Ça doit renvoyer une Promise qui s’accomplit avec un module dont l’export par défaut contient un composant React.</p>
<p>Le composant importé dynamiquement devrait être exploité dans un composant Suspense, qui nous permet d’afficher un contenu de repli (ex. un indicateur de chargement) en attendant que ce module soit chargé.</p>
<pre><code>import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    &#x3C;div>
      &#x3C;Suspense fallback={&#x3C;div>Chargement...&#x3C;/div>}>
        &#x3C;OtherComponent />
      &#x3C;/Suspense>
    &#x3C;/div>
  );
}
</code></pre>
<p>Décider où introduire un découpage dynamique de code dans une application peut s’avérer délicat. On veut être sûr·e de choisir des endroits qui fractionnent les bundles de manière uniforme, sans perturber l’expérience utilisateur.</p>
<p>Les routes sont un bon endroit pour commencer. La plupart des gens sont habitués sur le web à ce que les transitions entre les pages mettent du temps à charger.</p>
<h3>Exports nommés</h3>
<p>Pour le moment, React.lazy ne prend en charge que les exports par défaut. Si le module que vous souhaitez importer utilise des exports nommés, vous pouvez créer un module intermédiaire qui réexportera le composant voulu en tant qu’export par défaut. Cela garantit que le *tree shaking (*<strong>Tree shaking</strong> est un terme couramment utilisé dans un contexte JavaScript pour décrire la suppression du code mort.)</p>
<pre><code>// ManyComponents.js
export const MyComponent = /* ... */;
export const MyUnusedComponent = /* ... */;
// MyComponent.js
export { MyComponent as default } from "./ManyComponents.js";
// MyApp.js
import React, { lazy } from 'react';
const MyComponent = lazy(() => import("./MyComponent.js"));
</code></pre>
<hr>
<h2>Contexte</h2>
<p>Dans une application React typique, les données sont passées de haut en bas (du parent à l’enfant) via les props, mais cela peut devenir lourd pour certains types de props (ex. les préférences régionales, le thème de l’interface utilisateur) qui s’avèrent nécessaires pour de nombreux composants au sein d’une application.</p>
<p>Le Contexte offre un moyen de partager des valeurs comme celles-ci entre des composants sans avoir à explicitement passer une prop à chaque niveau de l’arborescence.</p>
<pre><code>const MyContext = React.createContext(defaultValue);
</code></pre>
<p>Lorsque React affiche un composant qui s’abonne à cet objet Context, il lira la valeur actuelle du contexte depuis le <strong>Provider</strong> le plus proche situé plus haut dans l’arborescence.</p>
<p>L’argument <code>defaultValue</code> est uniquement ****utilisé lorsqu’un composant n’a pas de Provider correspondant au-dessus de lui dans l’arborescence.</p>
<p>Chaque objet Contexte est livré avec un composant React Provider qui permet aux composants consommateurs de s’abonner aux mises à jour du contexte.</p>
<p>Tous les consommateurs qui sont descendants d’un Provider se rafraîchiront lorsque la prop value
 du Provider change.</p>
<p>Pour s’abonner au context, 2 façons de faire:</p>
<pre><code>&#x3C;MyContext.Consumer>
  {value => /* affiche quelque chose basé sur la valeur du contexte */}
&#x3C;/MyContext.Consumer>

// OU

const value = useContext()
&#x3C;div>{value}&#x3C;/div>
</code></pre>
<p>Il est souvent nécessaire de mettre à jour le contexte à partir d’un composant imbriqué profondément dans l’arbre des composants. Dans un tel cas, on peut passer une fonction à travers le contexte qui permet aux consommateurs de le mettre à jour.</p>
<h3>Limitations</h3>
<p>Dans la mesure où le contexte utilise une identité référentielle pour déterminer quand se rafraîchir, il y a des cas piégeux qui peuvent déclencher des rafraîchissements involontaires pour les consommateurs lorsque le parent d’un fournisseur se rafraîchit.</p>
<hr>
<h2>Transfert de Refs</h2>
<p>Le transfert de ref est une technique permettant de déléguer automatiquement une 
ref d’un composant à l’un de ses enfants.</p>
<p>exemple:</p>
<pre><code>function FancyButton(props) {
  return (
    &#x3C;button className="FancyButton">
      {props.children}
    &#x3C;/button>);
}

// APRES
const FancyButton = React.forwardRef((props, ref) => (
  &#x3C;button ref={ref} className="FancyButton">
    {props.children}
  &#x3C;/button>
));

// Vous pouvez maintenant obtenir une ref directement attachée au bouton DOM :
const ref = React.createRef();
&#x3C;FancyButton ref={ref}>Cliquez ici&#x3C;/FancyButton>;
</code></pre>
<p>De cette façon, les composants utilisant FancyButton peuvent obtenir une ref sur le nœud DOM button sous-jacent et y accéder si nécessaire, comme s’ils utilisaient directement un button DOM.</p>
<ol>
<li>Création d’une <a href="https://fr.reactjs.org/docs/refs-and-the-dom.html">ref React</a> en appelant React.createRef et l’affectons à une variable ref.</li>
<li>Passage de la variable ref à <code>&#x3C;FancyButton ref={ref}></code> en la spécifiant comme un attribut JSX.</li>
<li>React transmet la <code>ref</code> à la fonction <code>(props, ref) => ...</code> à l’intérieur de <code>forwardRef</code> comme deuxième argument.</li>
<li>Transfert de cet argument <code>ref</code> au <code>&#x3C;button ref={ref}></code> en le spécifiant comme un attribut JSX.</li>
<li>Quand la ref est liée, <code>ref.current</code> pointera vers le nœud DOM <code>button</code>.</li>
</ol>
<h2>HOC ou Composants d’ordre supérieur</h2>
<p>C’est une technique avancée de React qui permet de réutiliser la logique de composants.</p>
<p>Les HOC ne font pas partie de l’API de React à proprement parler, mais découlent de sa nature compositionnelle.</p>
<p><strong>Un composant d’ordre supérieur est une fonction qui accepte un composant et renvoie un nouveau composant.</strong></p>
<pre><code>const Component2 = higherOrderComponent(Component1);
</code></pre>
<p>Là où un composant transforme des props en interface utilisateur (UI), un composant d’ordre supérieur transforme un composant en un autre composant.</p>
<p>Les HOC sont courants dans des bibliothèques tierces de React, comme <code>[connect](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect)</code> dans Redux.</p>
<h3>Limitations</h3>
<p>L’algorithme de comparaison de React (qu’on appelle la réconciliation) utilise l’identité des composants pour déterminer s’il faut mettre à jour l’arborescence existante ou la jeter et en monter une nouvelle. Si le composant renvoyé par render est identique au composant du rendu précédent, React met récursivement à jour l’arborescence en la comparant avec la nouvelle. S’ils ne sont pas identiques, l’ancienne arborescence est intégralement démontée.</p>
<p>En général, vous ne devriez pas avoir à y penser. Mais dans le cadre des HOC c’est important, puisque ça signifie que vous ne pouvez pas appliquer un HOC au sein de la méthode de rendu d’un composant :</p>
<pre><code>render() {
  // Une nouvelle version de EnhancedComponent est créée à chaque rendu
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // Ça entraîne un démontage/remontage complet à chaque fois !
  return &#x3C;EnhancedComponent />;
}
</code></pre>
<p>Il ne s’agit pas uniquement d’un problème de performances : remonter un composant signifie que l’état local de ce composant ainsi que ceux de tous ses enfants seront perdus.</p>
<p>Il faut plutôt appliquer les HOC à l’extérieur de la définition d’un composant, afin de créer le composant enrobé une seule fois. Son identité sera alors constante d’un rendu à l’autre.</p>
<p>Si vous ajoutez une ref à un élément dont le composant résulte d’un HOC, la ref fait référence à une instance du composant conteneur extérieur, et non au composant enrobé. Les refs ne sont donc pas transmises.</p>
<p>La solution à ce problème réside dans l’utilisation de l’API <code>React.forwardRef</code>(introduite dans React 16.3)</p>
<hr>
<h2>Portails</h2>
<p>Les portails fournissent une excellente solution pour afficher des composants enfants dans un nœud DOM qui existe en dehors de la hiérarchie DOM du composant parent.</p>
<pre><code>ReactDOM.createPortal(child, container)
</code></pre>
<p>Un cas typique d’utilisation des portails survient lorsqu’un composant parent possède un style <code>overflow: hidden</code>ou <code>z-index</code> et que l’enfant a besoin de « sortir de son conteneur » visuellement. C’est par exemple le cas des boîtes de dialogues, des pop-ups ou encore des infobulles.</p>
<hr>
<h2>Réconciliation</h2>
<h3>Raisons</h3>
<p>Quand vous utilisez React, à chaque instant précis vous pouvez considérer que la fonction <code>render()</code> crée un arbre d’éléments React. Lors de la mise à jour suivante de l’état local ou des props, cette fonction <code>render()</code> renverra un arbre différent d’éléments React.</p>
<p>React doit alors déterminer comment mettre efficacement à jour l’interface utilisateur (UI) pour qu’elle corresponde à l’arbre le plus récent.</p>
<p>Il existe des solutions génériques à ce problème algorithmique consistant à générer le nombre minimal d’opérations pour transformer un arbre en un autre. Néanmoins, <a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">les algorithmes à la pointe de l’état de l’art</a> (en anglais) ont une complexité de l’ordre de <em>O(n3)</em> où <em>n</em> est le nombre d’éléments dans l’arbre.</p>
<p>Si nous les utilisions dans React, l’affichage de 1 000 éléments nécessiterait environ un milliard d’opérations. C’est beaucoup trop coûteux. React implémente plutôt un algorithme heuristique en <em>O(n)</em> basé sur deux hypothèses :</p>
<ol>
<li>Deux éléments de types différents produiront des arbres différents.</li>
<li>Le développeur peut indiquer quels éléments peuvent être stables d’un rendu à l’autre grâce à la prop <code>key</code>.</li>
</ol>
<p>En pratique, ces hypothèses sont valables dans presque tous les cas.</p>
<h3>L’algorithme de comparaison</h3>
<p>En comparant deux arbres, React va commencer par comparer les éléments racines. Le comportement est différent selon le type des éléments racines.</p>
<h3>Éléments de types différents</h3>
<p>Chaque fois que les éléments racines ont des types différents, React va détruire l’ancien arbre et reconstruire le nouvel arbre à partir de zéro. Passer de <code>&#x3C;a></code> à <code>&#x3C;img></code>, ou de <code>&#x3C;Article></code> à <code>&#x3C;Comment></code>, ou de <code>&#x3C;Button></code> à <code>&#x3C;div></code> : tous aboutiront à une reconstruction complète.</p>
<p>Lors de la destruction d’un arbre, les anciens nœuds DOM sont détruits. Les instances des composants reçoivent <code>componentWillUnmount()</code>. Lors de la construction d’un nouvel arbre, les nouveaux nœuds sont insérés dans le DOM. Les instances de composants reçoivent <code>UNSAFE_componentWillMount()</code> puis <code>componentDidMount()</code>. Tous les états associés à l’ancien arbre sont perdus.</p>
<p>Tous les composants au-dessous de la racine seront également démontés et leur état détruit. Par exemple, en comparant :</p>
<pre><code>&#x3C;div>
	&#x3C;Counter />
&#x3C;/div>
&#x3C;span>
	&#x3C;Counter />
&#x3C;/span>
</code></pre>
<p>Ça détruira l’ancien <code>Counter</code> puis en remontera un nouveau.</p>
<blockquote>
<p>Remarque</p>
<p>Les méthodes suivantes sont considérées dépréciées et vous devriez <a href="https://fr.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">les éviter</a> dans vos nouveaux codes :</p>
<ul>
<li><code>UNSAFE_componentWillMount()</code></li>
</ul>
</blockquote>
<h3>Éléments DOM de même type</h3>
<p>Lors de la comparaison entre deux éléments DOM React de même type, React examine les attributs des deux, conserve le même nœud DOM sous-jacent, et ne met à jour que les attributs modifiés. Par exemple :</p>
<pre><code>&#x3C;div className="before" title="stuff" />
&#x3C;div className="after" title="stuff" />
</code></pre>
<p>En comparant ces deux éléments, React sait qu’il ne faut modifier que le <code>className</code> du nœud DOM sous-jacent.</p>
<p>Lors d’une mise à jour du <code>style</code>, React là aussi sait ne mettre à jour que les propriétés qui ont changé. Par exemple :</p>
<pre><code>&#x3C;div style={{color: 'red', fontWeight: 'bold'}} />
&#x3C;div style={{color: 'green', fontWeight: 'bold'}} />
</code></pre>
<p>Lors de la conversion entre les deux éléments, React sait qu’il ne doit modifier que le style <code>color</code> et pas <code>fontWeight</code>.</p>
<p>Après avoir manipulé le nœud DOM, React applique le même traitement sur les enfants.</p>
<h3>Éléments composants de même type</h3>
<p>Lorsqu’un composant est mis à jour, l’instance reste la même, afin que l’état soit maintenu d’un rendu à l’autre. React met à jour les props de l’instance de composant sous-jacente pour correspondre au nouvel élément, et appelle <code>UNSAFE_componentWillReceiveProps()</code>, <code>UNSAFE_componentWillUpdate()</code> et <code>componentDidUpdate()</code> dessus.</p>
<p>Ensuite, la méthode <code>render()</code> est appelée et l’algorithme de comparaison reprend entre son résultat précédent et le nouveau.</p>
<blockquote>
<p>Remarque</p>
<p>Les méthodes suivantes sont considérées dépréciées et vous devriez les éviter dans vos nouveaux codes :</p>
<ul>
<li><code>UNSAFE_componentWillReceiveProps()</code></li>
<li><code>UNSAFE_componentWillUpdate()</code></li>
</ul>
</blockquote>
<h3>Traitement récursif sur les enfants</h3>
<p>Par défaut, lorsqu’il traite les enfants d’un nœud DOM, React parcourt simultanément les deux listes d’enfants et génère une modification chaque fois qu’il y a une différence.</p>
<p>Par exemple, lors de l’ajout d’un élément à la fin des enfants, la conversion entre les deux arbres fonctionne bien :</p>
<pre><code>&#x3C;ul>
	&#x3C;li>first&#x3C;/li>
	&#x3C;li>second&#x3C;/li>
&#x3C;/ul>
&#x3C;ul>
	&#x3C;li>first&#x3C;/li>
	&#x3C;li>second&#x3C;/li>
	&#x3C;li>third&#x3C;/li>
&#x3C;/ul>
</code></pre>
<p>React fera correspondre les deux arbres <code>&#x3C;li>first&#x3C;/li></code>, les deux arbres <code>&#x3C;li>second&#x3C;/li></code>, et insérera l’arbre <code>&#x3C;li>third&#x3C;/li></code>.</p>
<p>Si vous l’implémentez de façon naïve, l’insertion d’un élément au début aura de moins bonnes performances. Par exemple, la conversion entre ces deux arbres fonctionnera assez mal :</p>
<pre><code>&#x3C;ul>
	&#x3C;li>Duke&#x3C;/li>
	&#x3C;li>Villanova&#x3C;/li>
&#x3C;/ul>
&#x3C;ul>
	&#x3C;li>Connecticut&#x3C;/li>
	&#x3C;li>Duke&#x3C;/li>
	&#x3C;li>Villanova&#x3C;/li>
&#x3C;/ul>
</code></pre>
<p>React va modifier chaque enfant plutôt que de réaliser qu’il pouvait garder les sous-arbres <code>&#x3C;li>Duke&#x3C;/li></code> et <code>&#x3C;li>Villanova&#x3C;/li></code> intacts. Cette inefficacité peut être un problème.</p>
<h3>Clés</h3>
<p>Afin de résoudre ce problème, React prend en charge l’attribut <code>key</code>. Quand des enfants ont cette clé, React l’utilise pour faire correspondre les enfants de l’arbre d’origine avec les enfants de l’arbre suivant. Par exemple, l’ajout d’une <code>key</code> dans notre exemple inefficace peut rendre la conversion de l’arbre plus efficace :</p>
<pre><code>&#x3C;ul>
	&#x3C;li key="2015">Duke&#x3C;/li>
	&#x3C;li key="2016">Villanova&#x3C;/li>
&#x3C;/ul>
&#x3C;ul>
	&#x3C;li key="2014">Connecticut&#x3C;/li>
	&#x3C;li key="2015">Duke&#x3C;/li>
	&#x3C;li key="2016">Villanova&#x3C;/li>
&#x3C;/ul>
</code></pre>
<p>À présent, React sait que l’élément avec la clé <code>'2014'</code> est nouveau, et que les éléments avec les clés <code>'2015'</code> et <code>'2016'</code> ont juste été déplacés.</p>
<p>En pratique, trouver une clé n’est généralement pas difficile. L’élément que vous allez afficher peut déjà disposer d’un identifiant unique, la clé provenant alors de vos données :</p>
<pre><code>&#x3C;li key={item.id}>{item.name}&#x3C;/li>
</code></pre>
<p>Quand ce n’est pas le cas, vous pouvez ajouter une nouvelle propriété d’identification à votre modèle, ou hacher certaines parties de votre contenu pour générer une clé. La clé n’a besoin d’être unique que parmi ses éléments frères, et non au niveau global.</p>
<p>En dernier recours, vous pouvez utiliser l’index de l’élément dans un tableau comme clé. Cela fonctionne correctement si les éléments ne sont jamais réordonnés et s’il n’y a ni insertion ni suppression, dans le cas contraire ce serait assez lent.</p>
<p>Les tris peuvent également causer des problèmes avec les états des composants quand les index sont utilisés comme des clés. Les instances des composants sont mises à jour et réutilisées en fonction de leur clé. Si la clé est un index, déplacer un élément changera sa clé. En conséquence, l’état local des composants utilisés pour des saisies non-contrôlées peut s’emmêler et être mis à jour de manière inattendue.</p>
<h3>Compromis</h3>
<p>Rappelez-vous bien que l’algorithme de réconciliation est un détail d’implémentation. React pourrait rafraîchir l’ensemble de l’application à chaque action ; le résultat final serait le même. Pour être clair, rafraîchir dans ce contexte signifie appeler <code>render</code> sur tous les composants, ça ne signifie pas que React les démontera et remontera. Il n’appliquera que les différences obtenues en suivant les règles énoncées dans les sections précédentes.</p>
<p>Nous affinons régulièrement les heuristiques afin d’accélérer les cas d’usage courants. Dans l’implémentation actuelle, vous pouvez exprimer le fait qu’un sous-arbre a été déplacé parmi ses frères, mais vous ne pouvez pas dire qu’il a été déplacé ailleurs. L’algorithme va refaire le rendu de l’ensemble du sous-arbre.</p>
<p>Puisque React se repose sur des heuristiques, si les hypothèses derrière celles-ci s’avèrent erronées, ça réduira les performances.</p>
<ol>
<li>L’algorithme n’essaiera pas de faire correspondre des sous-arbres de types de composants différents. Si vous êtes amené·e à alterner entre deux types de composants au rendu très similaire, vous devriez peut-être en faire un type unique. En pratique, nous ne considérons pas ça comme un problème.</li>
<li>Les clés doivent être stables, prévisibles et uniques. Des clés instables (comme celles produites par <code>Math.random()</code>) entraîneront la re-création superflue de nombreuses instances de composants et de nœuds DOM, ce qui peut dégrader les performances et perdre l’état local des composants enfants.</li>
</ol>
<hr>
<h2>Les refs et le DOM</h2>
<h2>Mode concurrent (expérimental)</h2>
<h2>Services workers</h2>
</div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":{"id":"frontend-react-react","path":"frontend/react/react.md","content":"\u003cp\u003e\u003cstrong\u003eReact\u003c/strong\u003e est une bibliothèque JavaScript pour la construction d’interfaces utilisateur (UI).\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eJSX\u003c/h2\u003e\n\u003cp\u003eC’est une extension syntaxique de JavaScript qui permet de décrire à quoi devrait ressembler l’interface utilisateur. C’est un peu un mix entre un langage de balisage et de javascript.\u003c/p\u003e\n\u003cp\u003eJSX produit des « éléments » React qui seront ensuite retranscrit dans le DOM.\u003c/p\u003e\n\u003cp\u003eLe fonctionnement d’une UI conditionnera toujours les logiques de rendu, de la gestion des événements à la préparation des données pour l’affichage, en passant par l’évolution de l’état au fil du temps. React a choisi d’assumer pleinement cet état de fait.\u003c/p\u003e\n\u003cp\u003eAu lieu de séparer artificiellement les \u003cem\u003etechnologies\u003c/em\u003e en mettant le balisage et la logique dans des fichiers séparés, React sépare les \u003cem\u003epréoccupations (ou responsabilités)\u003c/em\u003e via des unités faiblement couplées appelées « composants », qui contiennent les deux.\u003c/p\u003e\n\u003cp\u003eReact n’oblige pas à utiliser JSX, mais la plupart des gens y trouvent une aide visuelle quand ils manipulent l’interface utilisateur dans le code JavaScript. Ça permet aussi à React de produire des messages d’erreurs et d’avertissements plus utiles.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst name = 'monde';\n\n// Il est possible de mettre n'importe quelle expression js dans les accolades\nconst element = \u0026#x3C;h1\u003eBonjour, {name}\u0026#x3C;/h1\u003e;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAprès la compilation, les expressions JSX deviennent de simples appels de fonctions js, dont l’évaluation renvoie des objets js.\u003c/p\u003e\n\u003cp\u003eÇa signifie que vous pouvez utiliser JSX à l’intérieur d’instructions \u003ccode\u003eif\u003c/code\u003e ou de boucles \u003ccode\u003efor\u003c/code\u003e, l’affecter à des variables, l’accepter en tant qu’argument, et le renvoyer depuis des fonctions :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getGreeting(user) {\n  if (user) {\n    return \u0026#x3C;h1\u003eBonjour, {formatName(user)} !\u0026#x3C;/h1\u003e;  \n\t}\n\n  return \u0026#x3C;h1\u003eBonjour, monde.\u0026#x3C;/h1\u003e;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBon à savoir: Dans la mesure où JSX est plus proche de JavaScript que de HTML, React DOM utilise la casse \u003ccode\u003ecamelCase\u003c/code\u003ecomme convention de nommage des propriétés, au lieu des noms d’attributs HTML. Donc pour les attributs, on aura className plutôt que class, etc,…\u003c/p\u003e\n\u003ch3\u003eSécurité\u003c/h3\u003e\n\u003cp\u003ePar défaut, React DOM échappe toutes les valeurs intégrées avec JSX avant d’en faire le rendu. ****\u003c/p\u003e\n\u003cp\u003eIl garantit ainsi que vous ne risquez jamais d’injecter quoi que ce soit d’autre que ce vous avez explicitement écrit dans votre application. Tout est converti en chaîne de caractères avant de produire le rendu. Ça aide à éviter les attaques XSS.\u003c/p\u003e\n\u003ch3\u003eJSX représente des objets\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003econst element = (\n  \u0026#x3C;h1 className=\"greeting\"\u003e\n    Bonjour, monde !\n  \u0026#x3C;/h1\u003e);\n\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Bonjour, monde !'\n);\n\n// React.createElement() effectue quelques vérifications pour vous aider\n// à écrire un code sans bug, mais pour l’essentiel il crée un objet qui \n// ressemble à ceci :\n\n// Remarque : cette structure est simplifiée\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Bonjour, monde !'\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003eRendu des éléments\u003c/h2\u003e\n\u003cp\u003eUn élément décrit ce que vous voulez voir à l’écran :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst element = \u0026#x3C;h1\u003eBonjour, monde\u0026#x3C;/h1\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eContrairement aux éléments DOM d’un navigateur, les éléments React sont de simples objets peu coûteux à créer. React DOM se charge de mettre à jour le DOM afin qu’il corresponde aux éléments React.\u003c/p\u003e\n\u003cp\u003eNous parlons de nœud DOM « racine » car tout ce qu’il contient sera géré par React DOM.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div id=\"root\"\u003e\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLes applications dévéloppées uniquement avec React ont généralement un seul nœud DOM racine. Si vous intégrez React dans une application existante, vous pouvez avoir autant de nœuds DOM racines isolés que vous le souhaitez.\u003c/p\u003e\n\u003cp\u003ePour faire le rendu d’un élément React dans un nœud DOM racine, passez les deux à la méthode \u003ccode\u003e[ReactDOM.render()](https://fr.reactjs.org/docs/react-dom.html#render)\u003c/code\u003e :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst element = \u0026#x3C;h1\u003eBonjour, monde\u0026#x3C;/h1\u003e;\nReactDOM.render(element, document.getElementById('root'));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLes éléments React sont \u003cstrong\u003eimmuables\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eUne fois votre élément créé, vous ne pouvez plus modifier ses enfants ou ses attributs. Un élément est comme une image d’un film à un instant T : il représente l’interface utilisateur à un point précis dans le temps.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction tick() {\n  const element = (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;h1\u003eBonjour, monde !\u0026#x3C;/h1\u003e\n      \u0026#x3C;h2\u003eIl est {new Date().toLocaleTimeString()}.\u0026#x3C;/h2\u003e\n    \u0026#x3C;/div\u003e\n  );\n  ReactDOM.render(element, document.getElementById('root'));\n}\n\nsetInterval(tick, 1000);\n// À chaque seconde, nous appellons ReactDOM.render() depuis une fonction de rappel \n// passée à setInterval().\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact DOM compare l’élément et ses enfants avec la version précédente, et applique uniquement les mises à jour DOM nécessaires pour refléter l’état voulu.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eComposants et props\u003c/h2\u003e\n\u003cp\u003eLes composants permettent de découper l’interface utilisateur en éléments indépendants et réutilisables, permettant ainsi de considérer chaque élément de manière isolée.\u003c/p\u003e\n\u003cp\u003eConceptuellement, les composants sont comme des fonctions js. Ils acceptent des entrées quelconques (appelées « props ») et renvoient des éléments React décrivant ce qui doit apparaître à l’écran.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst Welcome = (props) =\u003e {\n  return (\n\t\t\u0026#x3C;h1\u003eBonjour, {props.name}\u0026#x3C;/h1\u003e\n\t);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCette fonction est un composant React valide car elle accepte un seul argument « props » (qui signifie « propriétés ») contenant des données, et renvoie un élément React. Nous appelons de tels composants des « fonctions composants », car ce sont littéralement des fonctions js.\u003c/p\u003e\n\u003cp\u003eJusqu’ici, nous n’avons rencontré que des éléments React représentant des balises DOM :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst element = \u0026#x3C;div /\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMais ces éléments peuvent également représenter des composants définis par l’utilisateur :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst element = \u0026#x3C;Welcome name=\"Sara\" /\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eProps\u003c/h3\u003e\n\u003cp\u003eUn composant ne doit jamais modifier ses propres props.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTout composant React doit agir comme une fonction pure vis-à-vis de ses props.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBien entendu, les interfaces utilisateurs des applications sont dynamiques et évoluent dans le temps, on introduit donc le concept d’ \u003cstrong\u003eétat local.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eL’état local permet aux composants React de modifier leur sortie au fil du temps en fonction des actions de l’utilisateur, des réponses réseau et de n’importe quoi d’autre, mais sans enfreindre cette règle.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eGérer les événements\u003c/h2\u003e\n\u003cp\u003eLa gestion des événements pour les éléments React est très similaire à celle des éléments du DOM.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst ActionLink = () =\u003e {\n// e est un événement synthétique\n  const handleClick = (e) =\u003e {\n    e.preventDefault();\n    console.log('Le lien a été cliqué.');\n  }\n\n  return (\n    \u0026#x3C;a href=\"#\" onClick={handleClick}\u003e\n      Clique ici\n    \u0026#x3C;/a\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLorsque vous utilisez React, vous n’avez généralement pas besoin d’appeler la méthode \u003ccode\u003eaddEventListener\u003c/code\u003e pour ajouter des écouteurs d’événements.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eComposition ?\u003c/h2\u003e\n\u003cp\u003eReact fournit un puissant modèle de composition, aussi il est recommandé d’utiliser la composition plutôt que l’héritage pour réutiliser du code entre les composants.\u003c/p\u003e\n\u003ch3\u003eDélégation de contenu\u003c/h3\u003e\n\u003cp\u003eCertains composants ne connaissent pas leurs enfants à l’avance. C’est particulièrement courant pour des composants comme \u003ccode\u003eSidebar\u003c/code\u003e ou \u003ccode\u003eDialog\u003c/code\u003e, qui représentent des blocs génériques.\u003c/p\u003e\n\u003cp\u003ePour de tels composants, nous vous conseillons d’utiliser la prop spéciale \u003ccode\u003echildren\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eexemple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction FancyBorder(props) {\n  return (\n    \u0026#x3C;div\u003e\n      {props.children}\n    \u0026#x3C;/div\u003e\n  );\n}\n// Ça permet aux autres composants de leur passer des enfants quelconques\nfunction WelcomeDialog() {\n  return (\n    \u0026#x3C;FancyBorder\u003e\n      \u0026#x3C;h1\u003eBienvenue\u0026#x3C;/h1\u003e\n    \u0026#x3C;/FancyBorder\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSpécialisation\u003c/h3\u003e\n\u003cp\u003eParfois, nous voyons les composants comme des « cas particuliers » d’autres composants. Par exemple, nous pourrions dire que \u003ccode\u003eWelcomeDialog\u003c/code\u003eest un cas particulier de \u003ccode\u003eDialog\u003c/code\u003e.\nAvec React, on réalise ça avec la composition ; un composant plus « spécialisé » utilise un composant plus « générique » et le configure grâce aux props.\u003c/p\u003e\n\u003cp\u003eExemple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction WelcomeDialog() {\n  return (\n\t\t\u0026#x3C;\u003e\n\t\t\t\u0026#x3C;h1\u003eHello !\u0026#x3C;/h1\u003e\n\t    \u0026#x3C;Dialog\n\t      title=\"Bienvenue\"\n\t      message=\"Merci de visiter notre vaisseau spatial !\" /\u003e\n\t\t\u0026#x3C;/\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLes props et la composition donnent toute la flexibilité pour personnaliser l’apparence et le comportement d’un composant de manière explicite et sûre. (un composant peut accepter tout type de props, y compris des valeurs primitives, des éléments React et des fonctions.)\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eDécoupage dynamique de code\u003c/h2\u003e\n\u003ch3\u003eBundling\u003c/h3\u003e\n\u003cp\u003eLa plupart des applications React empaquetteront leur fichiers au moyen d’outils tels que Webpack, Rollup ou Browserify. L’empaquetage \u003cem\u003e(bundling)\u003c/em\u003e consiste à suivre le graphe des importations dans les fichiers, et à les regrouper au sein d’un même fichier : un bundle. Ce bundle peut ensuite être inclus dans une page web pour charger une application entière d’un seul coup.****\u003c/p\u003e\n\u003cp\u003eLes bundles c’est génial, mais au fur et à mesure qu’une application grandit, son bundle va grossir aussi. Surtout si de grosses bibliothèques tierces y sont intégrées.\u003c/p\u003e\n\u003cp\u003eIl est important de garder un œil sur le code qu’on intègre dans un bundle pour éviter de le rendre si lourd que le chargement de l’ application prendrait beaucoup de temps.\u003c/p\u003e\n\u003cp\u003ePour éviter de se retrouver avec un bundle trop volumineux, il est bon d’anticiper les problèmes et de commencer à fractionner le bundle. Le découpage dynamique de code est une fonctionnalité prise en charge par des empaqueteurs, qui permet de créer plusieurs bundles pouvant être chargés dynamiquement au moment de l’exécution.\u003c/p\u003e\n\u003cp\u003eFractionner une application peut aider à charger à la demande \u003cem\u003e(lazy-load)\u003c/em\u003e les parties qui sont nécessaires pour l’utilisateur à un moment donné, ce qui peut améliorer considérablement les performances de l’application. Bien que la quantité de code de l’application n’est pas été diminuée, on évite de charger du code dont l’utilisateur n’aura peut-être jamais besoin, et on réduit la quantité de code nécessaire au chargement initial.****\u003c/p\u003e\n\u003ch3\u003eImport dynamique\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e// AVANT\nimport { add } from './math';\n\nconsole.log(add(16, 26));\n\n// APRES\nimport(\"./math\").then(math =\u003e {\n  console.log(math.add(16, 26));\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eReact.lazy\u003c/h3\u003e\n\u003cp\u003eRemarque: \u003ccode\u003eReact.lazy\u003c/code\u003eet \u003ccode\u003eSuspense\u003c/code\u003e ne sont pas encore disponibles pour le rendu côté serveur.\u003c/p\u003e\n\u003cp\u003eLa fonction React.lazy permet d’afficher un composant importé dynamiquement comme n’importe quel autre composant.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// AVANT\nimport OtherComponent from './OtherComponent'\n// APRES\nconst OtherComponent = React.lazy(() =\u003e import('./OtherComponent'))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eÇa chargera automatiquement le bundle contenant le composant OtherComponent quand celui-ci sera rendu pour la première fois.\u003c/p\u003e\n\u003cp\u003eReact.lazy prend une fonction qui doit appeler un import() dynamique. Ça doit renvoyer une Promise qui s’accomplit avec un module dont l’export par défaut contient un composant React.\u003c/p\u003e\n\u003cp\u003eLe composant importé dynamiquement devrait être exploité dans un composant Suspense, qui nous permet d’afficher un contenu de repli (ex. un indicateur de chargement) en attendant que ce module soit chargé.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() =\u003e import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    \u0026#x3C;div\u003e\n      \u0026#x3C;Suspense fallback={\u0026#x3C;div\u003eChargement...\u0026#x3C;/div\u003e}\u003e\n        \u0026#x3C;OtherComponent /\u003e\n      \u0026#x3C;/Suspense\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDécider où introduire un découpage dynamique de code dans une application peut s’avérer délicat. On veut être sûr·e de choisir des endroits qui fractionnent les bundles de manière uniforme, sans perturber l’expérience utilisateur.\u003c/p\u003e\n\u003cp\u003eLes routes sont un bon endroit pour commencer. La plupart des gens sont habitués sur le web à ce que les transitions entre les pages mettent du temps à charger.\u003c/p\u003e\n\u003ch3\u003eExports nommés\u003c/h3\u003e\n\u003cp\u003ePour le moment, React.lazy ne prend en charge que les exports par défaut. Si le module que vous souhaitez importer utilise des exports nommés, vous pouvez créer un module intermédiaire qui réexportera le composant voulu en tant qu’export par défaut. Cela garantit que le *tree shaking (*\u003cstrong\u003eTree shaking\u003c/strong\u003e est un terme couramment utilisé dans un contexte JavaScript pour décrire la suppression du code mort.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// ManyComponents.js\nexport const MyComponent = /* ... */;\nexport const MyUnusedComponent = /* ... */;\n// MyComponent.js\nexport { MyComponent as default } from \"./ManyComponents.js\";\n// MyApp.js\nimport React, { lazy } from 'react';\nconst MyComponent = lazy(() =\u003e import(\"./MyComponent.js\"));\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003eContexte\u003c/h2\u003e\n\u003cp\u003eDans une application React typique, les données sont passées de haut en bas (du parent à l’enfant) via les props, mais cela peut devenir lourd pour certains types de props (ex. les préférences régionales, le thème de l’interface utilisateur) qui s’avèrent nécessaires pour de nombreux composants au sein d’une application.\u003c/p\u003e\n\u003cp\u003eLe Contexte offre un moyen de partager des valeurs comme celles-ci entre des composants sans avoir à explicitement passer une prop à chaque niveau de l’arborescence.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst MyContext = React.createContext(defaultValue);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLorsque React affiche un composant qui s’abonne à cet objet Context, il lira la valeur actuelle du contexte depuis le \u003cstrong\u003eProvider\u003c/strong\u003e le plus proche situé plus haut dans l’arborescence.\u003c/p\u003e\n\u003cp\u003eL’argument \u003ccode\u003edefaultValue\u003c/code\u003e est uniquement ****utilisé lorsqu’un composant n’a pas de Provider correspondant au-dessus de lui dans l’arborescence.\u003c/p\u003e\n\u003cp\u003eChaque objet Contexte est livré avec un composant React Provider qui permet aux composants consommateurs de s’abonner aux mises à jour du contexte.\u003c/p\u003e\n\u003cp\u003eTous les consommateurs qui sont descendants d’un Provider se rafraîchiront lorsque la prop value\n du Provider change.\u003c/p\u003e\n\u003cp\u003ePour s’abonner au context, 2 façons de faire:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;MyContext.Consumer\u003e\n  {value =\u003e /* affiche quelque chose basé sur la valeur du contexte */}\n\u0026#x3C;/MyContext.Consumer\u003e\n\n// OU\n\nconst value = useContext()\n\u0026#x3C;div\u003e{value}\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIl est souvent nécessaire de mettre à jour le contexte à partir d’un composant imbriqué profondément dans l’arbre des composants. Dans un tel cas, on peut passer une fonction à travers le contexte qui permet aux consommateurs de le mettre à jour.\u003c/p\u003e\n\u003ch3\u003eLimitations\u003c/h3\u003e\n\u003cp\u003eDans la mesure où le contexte utilise une identité référentielle pour déterminer quand se rafraîchir, il y a des cas piégeux qui peuvent déclencher des rafraîchissements involontaires pour les consommateurs lorsque le parent d’un fournisseur se rafraîchit.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eTransfert de Refs\u003c/h2\u003e\n\u003cp\u003eLe transfert de ref est une technique permettant de déléguer automatiquement une \nref d’un composant à l’un de ses enfants.\u003c/p\u003e\n\u003cp\u003eexemple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction FancyButton(props) {\n  return (\n    \u0026#x3C;button className=\"FancyButton\"\u003e\n      {props.children}\n    \u0026#x3C;/button\u003e);\n}\n\n// APRES\nconst FancyButton = React.forwardRef((props, ref) =\u003e (\n  \u0026#x3C;button ref={ref} className=\"FancyButton\"\u003e\n    {props.children}\n  \u0026#x3C;/button\u003e\n));\n\n// Vous pouvez maintenant obtenir une ref directement attachée au bouton DOM :\nconst ref = React.createRef();\n\u0026#x3C;FancyButton ref={ref}\u003eCliquez ici\u0026#x3C;/FancyButton\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDe cette façon, les composants utilisant FancyButton peuvent obtenir une ref sur le nœud DOM button sous-jacent et y accéder si nécessaire, comme s’ils utilisaient directement un button DOM.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCréation d’une \u003ca href=\"https://fr.reactjs.org/docs/refs-and-the-dom.html\"\u003eref React\u003c/a\u003e en appelant React.createRef et l’affectons à une variable ref.\u003c/li\u003e\n\u003cli\u003ePassage de la variable ref à \u003ccode\u003e\u0026#x3C;FancyButton ref={ref}\u003e\u003c/code\u003e en la spécifiant comme un attribut JSX.\u003c/li\u003e\n\u003cli\u003eReact transmet la \u003ccode\u003eref\u003c/code\u003e à la fonction \u003ccode\u003e(props, ref) =\u003e ...\u003c/code\u003e à l’intérieur de \u003ccode\u003eforwardRef\u003c/code\u003e comme deuxième argument.\u003c/li\u003e\n\u003cli\u003eTransfert de cet argument \u003ccode\u003eref\u003c/code\u003e au \u003ccode\u003e\u0026#x3C;button ref={ref}\u003e\u003c/code\u003e en le spécifiant comme un attribut JSX.\u003c/li\u003e\n\u003cli\u003eQuand la ref est liée, \u003ccode\u003eref.current\u003c/code\u003e pointera vers le nœud DOM \u003ccode\u003ebutton\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eHOC ou Composants d’ordre supérieur\u003c/h2\u003e\n\u003cp\u003eC’est une technique avancée de React qui permet de réutiliser la logique de composants.\u003c/p\u003e\n\u003cp\u003eLes HOC ne font pas partie de l’API de React à proprement parler, mais découlent de sa nature compositionnelle.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUn composant d’ordre supérieur est une fonction qui accepte un composant et renvoie un nouveau composant.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst Component2 = higherOrderComponent(Component1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLà où un composant transforme des props en interface utilisateur (UI), un composant d’ordre supérieur transforme un composant en un autre composant.\u003c/p\u003e\n\u003cp\u003eLes HOC sont courants dans des bibliothèques tierces de React, comme \u003ccode\u003e[connect](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect)\u003c/code\u003e dans Redux.\u003c/p\u003e\n\u003ch3\u003eLimitations\u003c/h3\u003e\n\u003cp\u003eL’algorithme de comparaison de React (qu’on appelle la réconciliation) utilise l’identité des composants pour déterminer s’il faut mettre à jour l’arborescence existante ou la jeter et en monter une nouvelle. Si le composant renvoyé par render est identique au composant du rendu précédent, React met récursivement à jour l’arborescence en la comparant avec la nouvelle. S’ils ne sont pas identiques, l’ancienne arborescence est intégralement démontée.\u003c/p\u003e\n\u003cp\u003eEn général, vous ne devriez pas avoir à y penser. Mais dans le cadre des HOC c’est important, puisque ça signifie que vous ne pouvez pas appliquer un HOC au sein de la méthode de rendu d’un composant :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erender() {\n  // Une nouvelle version de EnhancedComponent est créée à chaque rendu\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // Ça entraîne un démontage/remontage complet à chaque fois !\n  return \u0026#x3C;EnhancedComponent /\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIl ne s’agit pas uniquement d’un problème de performances : remonter un composant signifie que l’état local de ce composant ainsi que ceux de tous ses enfants seront perdus.\u003c/p\u003e\n\u003cp\u003eIl faut plutôt appliquer les HOC à l’extérieur de la définition d’un composant, afin de créer le composant enrobé une seule fois. Son identité sera alors constante d’un rendu à l’autre.\u003c/p\u003e\n\u003cp\u003eSi vous ajoutez une ref à un élément dont le composant résulte d’un HOC, la ref fait référence à une instance du composant conteneur extérieur, et non au composant enrobé. Les refs ne sont donc pas transmises.\u003c/p\u003e\n\u003cp\u003eLa solution à ce problème réside dans l’utilisation de l’API \u003ccode\u003eReact.forwardRef\u003c/code\u003e(introduite dans React 16.3)\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003ePortails\u003c/h2\u003e\n\u003cp\u003eLes portails fournissent une excellente solution pour afficher des composants enfants dans un nœud DOM qui existe en dehors de la hiérarchie DOM du composant parent.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eReactDOM.createPortal(child, container)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUn cas typique d’utilisation des portails survient lorsqu’un composant parent possède un style \u003ccode\u003eoverflow: hidden\u003c/code\u003eou \u003ccode\u003ez-index\u003c/code\u003e et que l’enfant a besoin de « sortir de son conteneur » visuellement. C’est par exemple le cas des boîtes de dialogues, des pop-ups ou encore des infobulles.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eRéconciliation\u003c/h2\u003e\n\u003ch3\u003eRaisons\u003c/h3\u003e\n\u003cp\u003eQuand vous utilisez React, à chaque instant précis vous pouvez considérer que la fonction \u003ccode\u003erender()\u003c/code\u003e crée un arbre d’éléments React. Lors de la mise à jour suivante de l’état local ou des props, cette fonction \u003ccode\u003erender()\u003c/code\u003e renverra un arbre différent d’éléments React.\u003c/p\u003e\n\u003cp\u003eReact doit alors déterminer comment mettre efficacement à jour l’interface utilisateur (UI) pour qu’elle corresponde à l’arbre le plus récent.\u003c/p\u003e\n\u003cp\u003eIl existe des solutions génériques à ce problème algorithmique consistant à générer le nombre minimal d’opérations pour transformer un arbre en un autre. Néanmoins, \u003ca href=\"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\"\u003eles algorithmes à la pointe de l’état de l’art\u003c/a\u003e (en anglais) ont une complexité de l’ordre de \u003cem\u003eO(n3)\u003c/em\u003e où \u003cem\u003en\u003c/em\u003e est le nombre d’éléments dans l’arbre.\u003c/p\u003e\n\u003cp\u003eSi nous les utilisions dans React, l’affichage de 1 000 éléments nécessiterait environ un milliard d’opérations. C’est beaucoup trop coûteux. React implémente plutôt un algorithme heuristique en \u003cem\u003eO(n)\u003c/em\u003e basé sur deux hypothèses :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDeux éléments de types différents produiront des arbres différents.\u003c/li\u003e\n\u003cli\u003eLe développeur peut indiquer quels éléments peuvent être stables d’un rendu à l’autre grâce à la prop \u003ccode\u003ekey\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEn pratique, ces hypothèses sont valables dans presque tous les cas.\u003c/p\u003e\n\u003ch3\u003eL’algorithme de comparaison\u003c/h3\u003e\n\u003cp\u003eEn comparant deux arbres, React va commencer par comparer les éléments racines. Le comportement est différent selon le type des éléments racines.\u003c/p\u003e\n\u003ch3\u003eÉléments de types différents\u003c/h3\u003e\n\u003cp\u003eChaque fois que les éléments racines ont des types différents, React va détruire l’ancien arbre et reconstruire le nouvel arbre à partir de zéro. Passer de \u003ccode\u003e\u0026#x3C;a\u003e\u003c/code\u003e à \u003ccode\u003e\u0026#x3C;img\u003e\u003c/code\u003e, ou de \u003ccode\u003e\u0026#x3C;Article\u003e\u003c/code\u003e à \u003ccode\u003e\u0026#x3C;Comment\u003e\u003c/code\u003e, ou de \u003ccode\u003e\u0026#x3C;Button\u003e\u003c/code\u003e à \u003ccode\u003e\u0026#x3C;div\u003e\u003c/code\u003e : tous aboutiront à une reconstruction complète.\u003c/p\u003e\n\u003cp\u003eLors de la destruction d’un arbre, les anciens nœuds DOM sont détruits. Les instances des composants reçoivent \u003ccode\u003ecomponentWillUnmount()\u003c/code\u003e. Lors de la construction d’un nouvel arbre, les nouveaux nœuds sont insérés dans le DOM. Les instances de composants reçoivent \u003ccode\u003eUNSAFE_componentWillMount()\u003c/code\u003e puis \u003ccode\u003ecomponentDidMount()\u003c/code\u003e. Tous les états associés à l’ancien arbre sont perdus.\u003c/p\u003e\n\u003cp\u003eTous les composants au-dessous de la racine seront également démontés et leur état détruit. Par exemple, en comparant :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div\u003e\n\t\u0026#x3C;Counter /\u003e\n\u0026#x3C;/div\u003e\n\u0026#x3C;span\u003e\n\t\u0026#x3C;Counter /\u003e\n\u0026#x3C;/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eÇa détruira l’ancien \u003ccode\u003eCounter\u003c/code\u003e puis en remontera un nouveau.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRemarque\u003c/p\u003e\n\u003cp\u003eLes méthodes suivantes sont considérées dépréciées et vous devriez \u003ca href=\"https://fr.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\"\u003eles éviter\u003c/a\u003e dans vos nouveaux codes :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUNSAFE_componentWillMount()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eÉléments DOM de même type\u003c/h3\u003e\n\u003cp\u003eLors de la comparaison entre deux éléments DOM React de même type, React examine les attributs des deux, conserve le même nœud DOM sous-jacent, et ne met à jour que les attributs modifiés. Par exemple :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div className=\"before\" title=\"stuff\" /\u003e\n\u0026#x3C;div className=\"after\" title=\"stuff\" /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEn comparant ces deux éléments, React sait qu’il ne faut modifier que le \u003ccode\u003eclassName\u003c/code\u003e du nœud DOM sous-jacent.\u003c/p\u003e\n\u003cp\u003eLors d’une mise à jour du \u003ccode\u003estyle\u003c/code\u003e, React là aussi sait ne mettre à jour que les propriétés qui ont changé. Par exemple :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div style={{color: 'red', fontWeight: 'bold'}} /\u003e\n\u0026#x3C;div style={{color: 'green', fontWeight: 'bold'}} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLors de la conversion entre les deux éléments, React sait qu’il ne doit modifier que le style \u003ccode\u003ecolor\u003c/code\u003e et pas \u003ccode\u003efontWeight\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAprès avoir manipulé le nœud DOM, React applique le même traitement sur les enfants.\u003c/p\u003e\n\u003ch3\u003eÉléments composants de même type\u003c/h3\u003e\n\u003cp\u003eLorsqu’un composant est mis à jour, l’instance reste la même, afin que l’état soit maintenu d’un rendu à l’autre. React met à jour les props de l’instance de composant sous-jacente pour correspondre au nouvel élément, et appelle \u003ccode\u003eUNSAFE_componentWillReceiveProps()\u003c/code\u003e, \u003ccode\u003eUNSAFE_componentWillUpdate()\u003c/code\u003e et \u003ccode\u003ecomponentDidUpdate()\u003c/code\u003e dessus.\u003c/p\u003e\n\u003cp\u003eEnsuite, la méthode \u003ccode\u003erender()\u003c/code\u003e est appelée et l’algorithme de comparaison reprend entre son résultat précédent et le nouveau.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRemarque\u003c/p\u003e\n\u003cp\u003eLes méthodes suivantes sont considérées dépréciées et vous devriez les éviter dans vos nouveaux codes :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUNSAFE_componentWillReceiveProps()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUNSAFE_componentWillUpdate()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eTraitement récursif sur les enfants\u003c/h3\u003e\n\u003cp\u003ePar défaut, lorsqu’il traite les enfants d’un nœud DOM, React parcourt simultanément les deux listes d’enfants et génère une modification chaque fois qu’il y a une différence.\u003c/p\u003e\n\u003cp\u003ePar exemple, lors de l’ajout d’un élément à la fin des enfants, la conversion entre les deux arbres fonctionne bien :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;ul\u003e\n\t\u0026#x3C;li\u003efirst\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003esecond\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u0026#x3C;ul\u003e\n\t\u0026#x3C;li\u003efirst\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003esecond\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003ethird\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact fera correspondre les deux arbres \u003ccode\u003e\u0026#x3C;li\u003efirst\u0026#x3C;/li\u003e\u003c/code\u003e, les deux arbres \u003ccode\u003e\u0026#x3C;li\u003esecond\u0026#x3C;/li\u003e\u003c/code\u003e, et insérera l’arbre \u003ccode\u003e\u0026#x3C;li\u003ethird\u0026#x3C;/li\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSi vous l’implémentez de façon naïve, l’insertion d’un élément au début aura de moins bonnes performances. Par exemple, la conversion entre ces deux arbres fonctionnera assez mal :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;ul\u003e\n\t\u0026#x3C;li\u003eDuke\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003eVillanova\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u0026#x3C;ul\u003e\n\t\u0026#x3C;li\u003eConnecticut\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003eDuke\u0026#x3C;/li\u003e\n\t\u0026#x3C;li\u003eVillanova\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact va modifier chaque enfant plutôt que de réaliser qu’il pouvait garder les sous-arbres \u003ccode\u003e\u0026#x3C;li\u003eDuke\u0026#x3C;/li\u003e\u003c/code\u003e et \u003ccode\u003e\u0026#x3C;li\u003eVillanova\u0026#x3C;/li\u003e\u003c/code\u003e intacts. Cette inefficacité peut être un problème.\u003c/p\u003e\n\u003ch3\u003eClés\u003c/h3\u003e\n\u003cp\u003eAfin de résoudre ce problème, React prend en charge l’attribut \u003ccode\u003ekey\u003c/code\u003e. Quand des enfants ont cette clé, React l’utilise pour faire correspondre les enfants de l’arbre d’origine avec les enfants de l’arbre suivant. Par exemple, l’ajout d’une \u003ccode\u003ekey\u003c/code\u003e dans notre exemple inefficace peut rendre la conversion de l’arbre plus efficace :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;ul\u003e\n\t\u0026#x3C;li key=\"2015\"\u003eDuke\u0026#x3C;/li\u003e\n\t\u0026#x3C;li key=\"2016\"\u003eVillanova\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u0026#x3C;ul\u003e\n\t\u0026#x3C;li key=\"2014\"\u003eConnecticut\u0026#x3C;/li\u003e\n\t\u0026#x3C;li key=\"2015\"\u003eDuke\u0026#x3C;/li\u003e\n\t\u0026#x3C;li key=\"2016\"\u003eVillanova\u0026#x3C;/li\u003e\n\u0026#x3C;/ul\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eÀ présent, React sait que l’élément avec la clé \u003ccode\u003e'2014'\u003c/code\u003e est nouveau, et que les éléments avec les clés \u003ccode\u003e'2015'\u003c/code\u003e et \u003ccode\u003e'2016'\u003c/code\u003e ont juste été déplacés.\u003c/p\u003e\n\u003cp\u003eEn pratique, trouver une clé n’est généralement pas difficile. L’élément que vous allez afficher peut déjà disposer d’un identifiant unique, la clé provenant alors de vos données :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;li key={item.id}\u003e{item.name}\u0026#x3C;/li\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eQuand ce n’est pas le cas, vous pouvez ajouter une nouvelle propriété d’identification à votre modèle, ou hacher certaines parties de votre contenu pour générer une clé. La clé n’a besoin d’être unique que parmi ses éléments frères, et non au niveau global.\u003c/p\u003e\n\u003cp\u003eEn dernier recours, vous pouvez utiliser l’index de l’élément dans un tableau comme clé. Cela fonctionne correctement si les éléments ne sont jamais réordonnés et s’il n’y a ni insertion ni suppression, dans le cas contraire ce serait assez lent.\u003c/p\u003e\n\u003cp\u003eLes tris peuvent également causer des problèmes avec les états des composants quand les index sont utilisés comme des clés. Les instances des composants sont mises à jour et réutilisées en fonction de leur clé. Si la clé est un index, déplacer un élément changera sa clé. En conséquence, l’état local des composants utilisés pour des saisies non-contrôlées peut s’emmêler et être mis à jour de manière inattendue.\u003c/p\u003e\n\u003ch3\u003eCompromis\u003c/h3\u003e\n\u003cp\u003eRappelez-vous bien que l’algorithme de réconciliation est un détail d’implémentation. React pourrait rafraîchir l’ensemble de l’application à chaque action ; le résultat final serait le même. Pour être clair, rafraîchir dans ce contexte signifie appeler \u003ccode\u003erender\u003c/code\u003e sur tous les composants, ça ne signifie pas que React les démontera et remontera. Il n’appliquera que les différences obtenues en suivant les règles énoncées dans les sections précédentes.\u003c/p\u003e\n\u003cp\u003eNous affinons régulièrement les heuristiques afin d’accélérer les cas d’usage courants. Dans l’implémentation actuelle, vous pouvez exprimer le fait qu’un sous-arbre a été déplacé parmi ses frères, mais vous ne pouvez pas dire qu’il a été déplacé ailleurs. L’algorithme va refaire le rendu de l’ensemble du sous-arbre.\u003c/p\u003e\n\u003cp\u003ePuisque React se repose sur des heuristiques, si les hypothèses derrière celles-ci s’avèrent erronées, ça réduira les performances.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eL’algorithme n’essaiera pas de faire correspondre des sous-arbres de types de composants différents. Si vous êtes amené·e à alterner entre deux types de composants au rendu très similaire, vous devriez peut-être en faire un type unique. En pratique, nous ne considérons pas ça comme un problème.\u003c/li\u003e\n\u003cli\u003eLes clés doivent être stables, prévisibles et uniques. Des clés instables (comme celles produites par \u003ccode\u003eMath.random()\u003c/code\u003e) entraîneront la re-création superflue de nombreuses instances de composants et de nœuds DOM, ce qui peut dégrader les performances et perdre l’état local des composants enfants.\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003eLes refs et le DOM\u003c/h2\u003e\n\u003ch2\u003eMode concurrent (expérimental)\u003c/h2\u003e\n\u003ch2\u003eServices workers\u003c/h2\u003e\n","title":"React"}},"__N_SSG":true},"page":"/content/[id]","query":{"id":"frontend-react-react"},"buildId":"nipmgq2y6MMnOk2Zrye-t","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>