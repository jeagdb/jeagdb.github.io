{"pageProps":{"content":{"id":"frontend-react-react","path":"frontend/react/react.md","content":"<p><strong>React</strong> est une bibliothèque JavaScript pour la construction d’interfaces utilisateur (UI).</p>\n<hr>\n<h2>JSX</h2>\n<p>C’est une extension syntaxique de JavaScript qui permet de décrire à quoi devrait ressembler l’interface utilisateur. C’est un peu un mix entre un langage de balisage et de javascript.</p>\n<p>JSX produit des « éléments » React qui seront ensuite retranscrit dans le DOM.</p>\n<p>Le fonctionnement d’une UI conditionnera toujours les logiques de rendu, de la gestion des événements à la préparation des données pour l’affichage, en passant par l’évolution de l’état au fil du temps. React a choisi d’assumer pleinement cet état de fait.</p>\n<p>Au lieu de séparer artificiellement les <em>technologies</em> en mettant le balisage et la logique dans des fichiers séparés, React sépare les <em>préoccupations (ou responsabilités)</em> via des unités faiblement couplées appelées « composants », qui contiennent les deux.</p>\n<p>React n’oblige pas à utiliser JSX, mais la plupart des gens y trouvent une aide visuelle quand ils manipulent l’interface utilisateur dans le code JavaScript. Ça permet aussi à React de produire des messages d’erreurs et d’avertissements plus utiles.</p>\n<pre><code>const name = 'monde';\r\n\r\n// Il est possible de mettre n'importe quelle expression js dans les accolades\r\nconst element = &#x3C;h1>Bonjour, {name}&#x3C;/h1>;\r\n\r\nReactDOM.render(\r\n  element,\r\n  document.getElementById('root')\r\n);\n</code></pre>\n<p>Après la compilation, les expressions JSX deviennent de simples appels de fonctions js, dont l’évaluation renvoie des objets js.</p>\n<p>Ça signifie que vous pouvez utiliser JSX à l’intérieur d’instructions <code>if</code> ou de boucles <code>for</code>, l’affecter à des variables, l’accepter en tant qu’argument, et le renvoyer depuis des fonctions :</p>\n<pre><code>function getGreeting(user) {\r\n  if (user) {\r\n    return &#x3C;h1>Bonjour, {formatName(user)} !&#x3C;/h1>;  \r\n\t}\r\n\r\n  return &#x3C;h1>Bonjour, monde.&#x3C;/h1>;}\n</code></pre>\n<p>Bon à savoir: Dans la mesure où JSX est plus proche de JavaScript que de HTML, React DOM utilise la casse <code>camelCase</code>comme convention de nommage des propriétés, au lieu des noms d’attributs HTML. Donc pour les attributs, on aura className plutôt que class, etc,…</p>\n<h3>Sécurité</h3>\n<p>Par défaut, React DOM échappe toutes les valeurs intégrées avec JSX avant d’en faire le rendu. ****</p>\n<p>Il garantit ainsi que vous ne risquez jamais d’injecter quoi que ce soit d’autre que ce vous avez explicitement écrit dans votre application. Tout est converti en chaîne de caractères avant de produire le rendu. Ça aide à éviter les attaques XSS.</p>\n<h3>JSX représente des objets</h3>\n<pre><code>const element = (\r\n  &#x3C;h1 className=\"greeting\">\r\n    Bonjour, monde !\r\n  &#x3C;/h1>);\r\n\r\nconst element = React.createElement(\r\n  'h1',\r\n  {className: 'greeting'},\r\n  'Bonjour, monde !'\r\n);\r\n\r\n// React.createElement() effectue quelques vérifications pour vous aider\r\n// à écrire un code sans bug, mais pour l’essentiel il crée un objet qui \r\n// ressemble à ceci :\r\n\r\n// Remarque : cette structure est simplifiée\r\nconst element = {\r\n  type: 'h1',\r\n  props: {\r\n    className: 'greeting',\r\n    children: 'Bonjour, monde !'\r\n  }\r\n};\n</code></pre>\n<hr>\n<h2>Rendu des éléments</h2>\n<p>Un élément décrit ce que vous voulez voir à l’écran :</p>\n<pre><code>const element = &#x3C;h1>Bonjour, monde&#x3C;/h1>;\n</code></pre>\n<p>Contrairement aux éléments DOM d’un navigateur, les éléments React sont de simples objets peu coûteux à créer. React DOM se charge de mettre à jour le DOM afin qu’il corresponde aux éléments React.</p>\n<p>Nous parlons de nœud DOM « racine » car tout ce qu’il contient sera géré par React DOM.</p>\n<pre><code>&#x3C;div id=\"root\">&#x3C;/div>\n</code></pre>\n<p>Les applications dévéloppées uniquement avec React ont généralement un seul nœud DOM racine. Si vous intégrez React dans une application existante, vous pouvez avoir autant de nœuds DOM racines isolés que vous le souhaitez.</p>\n<p>Pour faire le rendu d’un élément React dans un nœud DOM racine, passez les deux à la méthode <code>[ReactDOM.render()](https://fr.reactjs.org/docs/react-dom.html#render)</code> :</p>\n<pre><code>const element = &#x3C;h1>Bonjour, monde&#x3C;/h1>;\r\nReactDOM.render(element, document.getElementById('root'));\n</code></pre>\n<p>Les éléments React sont <strong>immuables</strong>.</p>\n<p>Une fois votre élément créé, vous ne pouvez plus modifier ses enfants ou ses attributs. Un élément est comme une image d’un film à un instant T : il représente l’interface utilisateur à un point précis dans le temps.</p>\n<pre><code>function tick() {\r\n  const element = (\r\n    &#x3C;div>\r\n      &#x3C;h1>Bonjour, monde !&#x3C;/h1>\r\n      &#x3C;h2>Il est {new Date().toLocaleTimeString()}.&#x3C;/h2>\r\n    &#x3C;/div>\r\n  );\r\n  ReactDOM.render(element, document.getElementById('root'));\r\n}\r\n\r\nsetInterval(tick, 1000);\r\n// À chaque seconde, nous appellons ReactDOM.render() depuis une fonction de rappel \r\n// passée à setInterval().\n</code></pre>\n<p>React DOM compare l’élément et ses enfants avec la version précédente, et applique uniquement les mises à jour DOM nécessaires pour refléter l’état voulu.</p>\n<hr>\n<h2>Composants et props</h2>\n<p>Les composants permettent de découper l’interface utilisateur en éléments indépendants et réutilisables, permettant ainsi de considérer chaque élément de manière isolée.</p>\n<p>Conceptuellement, les composants sont comme des fonctions js. Ils acceptent des entrées quelconques (appelées « props ») et renvoient des éléments React décrivant ce qui doit apparaître à l’écran.</p>\n<pre><code>const Welcome = (props) => {\r\n  return (\r\n\t\t&#x3C;h1>Bonjour, {props.name}&#x3C;/h1>\r\n\t);\r\n}\n</code></pre>\n<p>Cette fonction est un composant React valide car elle accepte un seul argument « props » (qui signifie « propriétés ») contenant des données, et renvoie un élément React. Nous appelons de tels composants des « fonctions composants », car ce sont littéralement des fonctions js.</p>\n<p>Jusqu’ici, nous n’avons rencontré que des éléments React représentant des balises DOM :</p>\n<pre><code>const element = &#x3C;div />;\n</code></pre>\n<p>Mais ces éléments peuvent également représenter des composants définis par l’utilisateur :</p>\n<pre><code>const element = &#x3C;Welcome name=\"Sara\" />;\n</code></pre>\n<h3>Props</h3>\n<p>Un composant ne doit jamais modifier ses propres props.</p>\n<p><strong>Tout composant React doit agir comme une fonction pure vis-à-vis de ses props.</strong></p>\n<p>Bien entendu, les interfaces utilisateurs des applications sont dynamiques et évoluent dans le temps, on introduit donc le concept d’ <strong>état local.</strong></p>\n<p>L’état local permet aux composants React de modifier leur sortie au fil du temps en fonction des actions de l’utilisateur, des réponses réseau et de n’importe quoi d’autre, mais sans enfreindre cette règle.</p>\n<hr>\n<h2>Gérer les événements</h2>\n<p>La gestion des événements pour les éléments React est très similaire à celle des éléments du DOM.</p>\n<pre><code>const ActionLink = () => {\r\n// e est un événement synthétique\r\n  const handleClick = (e) => {\r\n    e.preventDefault();\r\n    console.log('Le lien a été cliqué.');\r\n  }\r\n\r\n  return (\r\n    &#x3C;a href=\"#\" onClick={handleClick}>\r\n      Clique ici\r\n    &#x3C;/a>\r\n  );\r\n}\n</code></pre>\n<p>Lorsque vous utilisez React, vous n’avez généralement pas besoin d’appeler la méthode <code>addEventListener</code> pour ajouter des écouteurs d’événements.</p>\n<hr>\n<h2>Composition ?</h2>\n<p>React fournit un puissant modèle de composition, aussi il est recommandé d’utiliser la composition plutôt que l’héritage pour réutiliser du code entre les composants.</p>\n<h3>Délégation de contenu</h3>\n<p>Certains composants ne connaissent pas leurs enfants à l’avance. C’est particulièrement courant pour des composants comme <code>Sidebar</code> ou <code>Dialog</code>, qui représentent des blocs génériques.</p>\n<p>Pour de tels composants, nous vous conseillons d’utiliser la prop spéciale <code>children</code></p>\n<p>exemple:</p>\n<pre><code>function FancyBorder(props) {\r\n  return (\r\n    &#x3C;div>\r\n      {props.children}\r\n    &#x3C;/div>\r\n  );\r\n}\r\n// Ça permet aux autres composants de leur passer des enfants quelconques\r\nfunction WelcomeDialog() {\r\n  return (\r\n    &#x3C;FancyBorder>\r\n      &#x3C;h1>Bienvenue&#x3C;/h1>\r\n    &#x3C;/FancyBorder>\r\n  );\r\n}\n</code></pre>\n<h3>Spécialisation</h3>\n<p>Parfois, nous voyons les composants comme des « cas particuliers » d’autres composants. Par exemple, nous pourrions dire que <code>WelcomeDialog</code>est un cas particulier de <code>Dialog</code>.\r\nAvec React, on réalise ça avec la composition ; un composant plus « spécialisé » utilise un composant plus « générique » et le configure grâce aux props.</p>\n<p>Exemple:</p>\n<pre><code>function WelcomeDialog() {\r\n  return (\r\n\t\t&#x3C;>\r\n\t\t\t&#x3C;h1>Hello !&#x3C;/h1>\r\n\t    &#x3C;Dialog\r\n\t      title=\"Bienvenue\"\r\n\t      message=\"Merci de visiter notre vaisseau spatial !\" />\r\n\t\t&#x3C;/>\r\n  );\r\n}\n</code></pre>\n<p>Les props et la composition donnent toute la flexibilité pour personnaliser l’apparence et le comportement d’un composant de manière explicite et sûre. (un composant peut accepter tout type de props, y compris des valeurs primitives, des éléments React et des fonctions.)</p>\n<hr>\n<h2>Découpage dynamique de code</h2>\n<h3>Bundling</h3>\n<p>La plupart des applications React empaquetteront leur fichiers au moyen d’outils tels que Webpack, Rollup ou Browserify. L’empaquetage <em>(bundling)</em> consiste à suivre le graphe des importations dans les fichiers, et à les regrouper au sein d’un même fichier : un bundle. Ce bundle peut ensuite être inclus dans une page web pour charger une application entière d’un seul coup.****</p>\n<p>Les bundles c’est génial, mais au fur et à mesure qu’une application grandit, son bundle va grossir aussi. Surtout si de grosses bibliothèques tierces y sont intégrées.</p>\n<p>Il est important de garder un œil sur le code qu’on intègre dans un bundle pour éviter de le rendre si lourd que le chargement de l’ application prendrait beaucoup de temps.</p>\n<p>Pour éviter de se retrouver avec un bundle trop volumineux, il est bon d’anticiper les problèmes et de commencer à fractionner le bundle. Le découpage dynamique de code est une fonctionnalité prise en charge par des empaqueteurs, qui permet de créer plusieurs bundles pouvant être chargés dynamiquement au moment de l’exécution.</p>\n<p>Fractionner une application peut aider à charger à la demande <em>(lazy-load)</em> les parties qui sont nécessaires pour l’utilisateur à un moment donné, ce qui peut améliorer considérablement les performances de l’application. Bien que la quantité de code de l’application n’est pas été diminuée, on évite de charger du code dont l’utilisateur n’aura peut-être jamais besoin, et on réduit la quantité de code nécessaire au chargement initial.****</p>\n<h3>Import dynamique</h3>\n<pre><code>// AVANT\r\nimport { add } from './math';\r\n\r\nconsole.log(add(16, 26));\r\n\r\n// APRES\r\nimport(\"./math\").then(math => {\r\n  console.log(math.add(16, 26));\r\n});\n</code></pre>\n<h3>React.lazy</h3>\n<p>Remarque: <code>React.lazy</code>et <code>Suspense</code> ne sont pas encore disponibles pour le rendu côté serveur.</p>\n<p>La fonction React.lazy permet d’afficher un composant importé dynamiquement comme n’importe quel autre composant.</p>\n<pre><code>// AVANT\r\nimport OtherComponent from './OtherComponent'\r\n// APRES\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'))\n</code></pre>\n<p>Ça chargera automatiquement le bundle contenant le composant OtherComponent quand celui-ci sera rendu pour la première fois.</p>\n<p>React.lazy prend une fonction qui doit appeler un import() dynamique. Ça doit renvoyer une Promise qui s’accomplit avec un module dont l’export par défaut contient un composant React.</p>\n<p>Le composant importé dynamiquement devrait être exploité dans un composant Suspense, qui nous permet d’afficher un contenu de repli (ex. un indicateur de chargement) en attendant que ce module soit chargé.</p>\n<pre><code>import React, { Suspense } from 'react';\r\n\r\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\r\n\r\nfunction MyComponent() {\r\n  return (\r\n    &#x3C;div>\r\n      &#x3C;Suspense fallback={&#x3C;div>Chargement...&#x3C;/div>}>\r\n        &#x3C;OtherComponent />\r\n      &#x3C;/Suspense>\r\n    &#x3C;/div>\r\n  );\r\n}\n</code></pre>\n<p>Décider où introduire un découpage dynamique de code dans une application peut s’avérer délicat. On veut être sûr·e de choisir des endroits qui fractionnent les bundles de manière uniforme, sans perturber l’expérience utilisateur.</p>\n<p>Les routes sont un bon endroit pour commencer. La plupart des gens sont habitués sur le web à ce que les transitions entre les pages mettent du temps à charger.</p>\n<h3>Exports nommés</h3>\n<p>Pour le moment, React.lazy ne prend en charge que les exports par défaut. Si le module que vous souhaitez importer utilise des exports nommés, vous pouvez créer un module intermédiaire qui réexportera le composant voulu en tant qu’export par défaut. Cela garantit que le *tree shaking (*<strong>Tree shaking</strong> est un terme couramment utilisé dans un contexte JavaScript pour décrire la suppression du code mort.)</p>\n<pre><code>// ManyComponents.js\r\nexport const MyComponent = /* ... */;\r\nexport const MyUnusedComponent = /* ... */;\r\n// MyComponent.js\r\nexport { MyComponent as default } from \"./ManyComponents.js\";\r\n// MyApp.js\r\nimport React, { lazy } from 'react';\r\nconst MyComponent = lazy(() => import(\"./MyComponent.js\"));\n</code></pre>\n<hr>\n<h2>Contexte</h2>\n<p>Dans une application React typique, les données sont passées de haut en bas (du parent à l’enfant) via les props, mais cela peut devenir lourd pour certains types de props (ex. les préférences régionales, le thème de l’interface utilisateur) qui s’avèrent nécessaires pour de nombreux composants au sein d’une application.</p>\n<p>Le Contexte offre un moyen de partager des valeurs comme celles-ci entre des composants sans avoir à explicitement passer une prop à chaque niveau de l’arborescence.</p>\n<pre><code>const MyContext = React.createContext(defaultValue);\n</code></pre>\n<p>Lorsque React affiche un composant qui s’abonne à cet objet Context, il lira la valeur actuelle du contexte depuis le <strong>Provider</strong> le plus proche situé plus haut dans l’arborescence.</p>\n<p>L’argument <code>defaultValue</code> est uniquement ****utilisé lorsqu’un composant n’a pas de Provider correspondant au-dessus de lui dans l’arborescence.</p>\n<p>Chaque objet Contexte est livré avec un composant React Provider qui permet aux composants consommateurs de s’abonner aux mises à jour du contexte.</p>\n<p>Tous les consommateurs qui sont descendants d’un Provider se rafraîchiront lorsque la prop value\r\n du Provider change.</p>\n<p>Pour s’abonner au context, 2 façons de faire:</p>\n<pre><code>&#x3C;MyContext.Consumer>\r\n  {value => /* affiche quelque chose basé sur la valeur du contexte */}\r\n&#x3C;/MyContext.Consumer>\r\n\r\n// OU\r\n\r\nconst value = useContext()\r\n&#x3C;div>{value}&#x3C;/div>\n</code></pre>\n<p>Il est souvent nécessaire de mettre à jour le contexte à partir d’un composant imbriqué profondément dans l’arbre des composants. Dans un tel cas, on peut passer une fonction à travers le contexte qui permet aux consommateurs de le mettre à jour.</p>\n<h3>Limitations</h3>\n<p>Dans la mesure où le contexte utilise une identité référentielle pour déterminer quand se rafraîchir, il y a des cas piégeux qui peuvent déclencher des rafraîchissements involontaires pour les consommateurs lorsque le parent d’un fournisseur se rafraîchit.</p>\n<hr>\n<h2>Transfert de Refs</h2>\n<p>Le transfert de ref est une technique permettant de déléguer automatiquement une \r\nref d’un composant à l’un de ses enfants.</p>\n<p>exemple:</p>\n<pre><code>function FancyButton(props) {\r\n  return (\r\n    &#x3C;button className=\"FancyButton\">\r\n      {props.children}\r\n    &#x3C;/button>);\r\n}\r\n\r\n// APRES\r\nconst FancyButton = React.forwardRef((props, ref) => (\r\n  &#x3C;button ref={ref} className=\"FancyButton\">\r\n    {props.children}\r\n  &#x3C;/button>\r\n));\r\n\r\n// Vous pouvez maintenant obtenir une ref directement attachée au bouton DOM :\r\nconst ref = React.createRef();\r\n&#x3C;FancyButton ref={ref}>Cliquez ici&#x3C;/FancyButton>;\n</code></pre>\n<p>De cette façon, les composants utilisant FancyButton peuvent obtenir une ref sur le nœud DOM button sous-jacent et y accéder si nécessaire, comme s’ils utilisaient directement un button DOM.</p>\n<ol>\n<li>Création d’une <a href=\"https://fr.reactjs.org/docs/refs-and-the-dom.html\">ref React</a> en appelant React.createRef et l’affectons à une variable ref.</li>\n<li>Passage de la variable ref à <code>&#x3C;FancyButton ref={ref}></code> en la spécifiant comme un attribut JSX.</li>\n<li>React transmet la <code>ref</code> à la fonction <code>(props, ref) => ...</code> à l’intérieur de <code>forwardRef</code> comme deuxième argument.</li>\n<li>Transfert de cet argument <code>ref</code> au <code>&#x3C;button ref={ref}></code> en le spécifiant comme un attribut JSX.</li>\n<li>Quand la ref est liée, <code>ref.current</code> pointera vers le nœud DOM <code>button</code>.</li>\n</ol>\n<h2>HOC ou Composants d’ordre supérieur</h2>\n<p>C’est une technique avancée de React qui permet de réutiliser la logique de composants.</p>\n<p>Les HOC ne font pas partie de l’API de React à proprement parler, mais découlent de sa nature compositionnelle.</p>\n<p><strong>Un composant d’ordre supérieur est une fonction qui accepte un composant et renvoie un nouveau composant.</strong></p>\n<pre><code>const Component2 = higherOrderComponent(Component1);\n</code></pre>\n<p>Là où un composant transforme des props en interface utilisateur (UI), un composant d’ordre supérieur transforme un composant en un autre composant.</p>\n<p>Les HOC sont courants dans des bibliothèques tierces de React, comme <code>[connect](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect)</code> dans Redux.</p>\n<h3>Limitations</h3>\n<p>L’algorithme de comparaison de React (qu’on appelle la réconciliation) utilise l’identité des composants pour déterminer s’il faut mettre à jour l’arborescence existante ou la jeter et en monter une nouvelle. Si le composant renvoyé par render est identique au composant du rendu précédent, React met récursivement à jour l’arborescence en la comparant avec la nouvelle. S’ils ne sont pas identiques, l’ancienne arborescence est intégralement démontée.</p>\n<p>En général, vous ne devriez pas avoir à y penser. Mais dans le cadre des HOC c’est important, puisque ça signifie que vous ne pouvez pas appliquer un HOC au sein de la méthode de rendu d’un composant :</p>\n<pre><code>render() {\r\n  // Une nouvelle version de EnhancedComponent est créée à chaque rendu\r\n  // EnhancedComponent1 !== EnhancedComponent2\r\n  const EnhancedComponent = enhance(MyComponent);\r\n  // Ça entraîne un démontage/remontage complet à chaque fois !\r\n  return &#x3C;EnhancedComponent />;\r\n}\n</code></pre>\n<p>Il ne s’agit pas uniquement d’un problème de performances : remonter un composant signifie que l’état local de ce composant ainsi que ceux de tous ses enfants seront perdus.</p>\n<p>Il faut plutôt appliquer les HOC à l’extérieur de la définition d’un composant, afin de créer le composant enrobé une seule fois. Son identité sera alors constante d’un rendu à l’autre.</p>\n<p>Si vous ajoutez une ref à un élément dont le composant résulte d’un HOC, la ref fait référence à une instance du composant conteneur extérieur, et non au composant enrobé. Les refs ne sont donc pas transmises.</p>\n<p>La solution à ce problème réside dans l’utilisation de l’API <code>React.forwardRef</code>(introduite dans React 16.3)</p>\n<hr>\n<h2>Portails</h2>\n<p>Les portails fournissent une excellente solution pour afficher des composants enfants dans un nœud DOM qui existe en dehors de la hiérarchie DOM du composant parent.</p>\n<pre><code>ReactDOM.createPortal(child, container)\n</code></pre>\n<p>Un cas typique d’utilisation des portails survient lorsqu’un composant parent possède un style <code>overflow: hidden</code>ou <code>z-index</code> et que l’enfant a besoin de « sortir de son conteneur » visuellement. C’est par exemple le cas des boîtes de dialogues, des pop-ups ou encore des infobulles.</p>\n<hr>\n<h2>Réconciliation</h2>\n<h3>Raisons</h3>\n<p>Quand vous utilisez React, à chaque instant précis vous pouvez considérer que la fonction <code>render()</code> crée un arbre d’éléments React. Lors de la mise à jour suivante de l’état local ou des props, cette fonction <code>render()</code> renverra un arbre différent d’éléments React.</p>\n<p>React doit alors déterminer comment mettre efficacement à jour l’interface utilisateur (UI) pour qu’elle corresponde à l’arbre le plus récent.</p>\n<p>Il existe des solutions génériques à ce problème algorithmique consistant à générer le nombre minimal d’opérations pour transformer un arbre en un autre. Néanmoins, <a href=\"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\">les algorithmes à la pointe de l’état de l’art</a> (en anglais) ont une complexité de l’ordre de <em>O(n3)</em> où <em>n</em> est le nombre d’éléments dans l’arbre.</p>\n<p>Si nous les utilisions dans React, l’affichage de 1 000 éléments nécessiterait environ un milliard d’opérations. C’est beaucoup trop coûteux. React implémente plutôt un algorithme heuristique en <em>O(n)</em> basé sur deux hypothèses :</p>\n<ol>\n<li>Deux éléments de types différents produiront des arbres différents.</li>\n<li>Le développeur peut indiquer quels éléments peuvent être stables d’un rendu à l’autre grâce à la prop <code>key</code>.</li>\n</ol>\n<p>En pratique, ces hypothèses sont valables dans presque tous les cas.</p>\n<h3>L’algorithme de comparaison</h3>\n<p>En comparant deux arbres, React va commencer par comparer les éléments racines. Le comportement est différent selon le type des éléments racines.</p>\n<h3>Éléments de types différents</h3>\n<p>Chaque fois que les éléments racines ont des types différents, React va détruire l’ancien arbre et reconstruire le nouvel arbre à partir de zéro. Passer de <code>&#x3C;a></code> à <code>&#x3C;img></code>, ou de <code>&#x3C;Article></code> à <code>&#x3C;Comment></code>, ou de <code>&#x3C;Button></code> à <code>&#x3C;div></code> : tous aboutiront à une reconstruction complète.</p>\n<p>Lors de la destruction d’un arbre, les anciens nœuds DOM sont détruits. Les instances des composants reçoivent <code>componentWillUnmount()</code>. Lors de la construction d’un nouvel arbre, les nouveaux nœuds sont insérés dans le DOM. Les instances de composants reçoivent <code>UNSAFE_componentWillMount()</code> puis <code>componentDidMount()</code>. Tous les états associés à l’ancien arbre sont perdus.</p>\n<p>Tous les composants au-dessous de la racine seront également démontés et leur état détruit. Par exemple, en comparant :</p>\n<pre><code>&#x3C;div>\r\n\t&#x3C;Counter />\r\n&#x3C;/div>\r\n&#x3C;span>\r\n\t&#x3C;Counter />\r\n&#x3C;/span>\n</code></pre>\n<p>Ça détruira l’ancien <code>Counter</code> puis en remontera un nouveau.</p>\n<blockquote>\n<p>Remarque</p>\n<p>Les méthodes suivantes sont considérées dépréciées et vous devriez <a href=\"https://fr.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\">les éviter</a> dans vos nouveaux codes :</p>\n<ul>\n<li><code>UNSAFE_componentWillMount()</code></li>\n</ul>\n</blockquote>\n<h3>Éléments DOM de même type</h3>\n<p>Lors de la comparaison entre deux éléments DOM React de même type, React examine les attributs des deux, conserve le même nœud DOM sous-jacent, et ne met à jour que les attributs modifiés. Par exemple :</p>\n<pre><code>&#x3C;div className=\"before\" title=\"stuff\" />\r\n&#x3C;div className=\"after\" title=\"stuff\" />\n</code></pre>\n<p>En comparant ces deux éléments, React sait qu’il ne faut modifier que le <code>className</code> du nœud DOM sous-jacent.</p>\n<p>Lors d’une mise à jour du <code>style</code>, React là aussi sait ne mettre à jour que les propriétés qui ont changé. Par exemple :</p>\n<pre><code>&#x3C;div style={{color: 'red', fontWeight: 'bold'}} />\r\n&#x3C;div style={{color: 'green', fontWeight: 'bold'}} />\n</code></pre>\n<p>Lors de la conversion entre les deux éléments, React sait qu’il ne doit modifier que le style <code>color</code> et pas <code>fontWeight</code>.</p>\n<p>Après avoir manipulé le nœud DOM, React applique le même traitement sur les enfants.</p>\n<h3>Éléments composants de même type</h3>\n<p>Lorsqu’un composant est mis à jour, l’instance reste la même, afin que l’état soit maintenu d’un rendu à l’autre. React met à jour les props de l’instance de composant sous-jacente pour correspondre au nouvel élément, et appelle <code>UNSAFE_componentWillReceiveProps()</code>, <code>UNSAFE_componentWillUpdate()</code> et <code>componentDidUpdate()</code> dessus.</p>\n<p>Ensuite, la méthode <code>render()</code> est appelée et l’algorithme de comparaison reprend entre son résultat précédent et le nouveau.</p>\n<blockquote>\n<p>Remarque</p>\n<p>Les méthodes suivantes sont considérées dépréciées et vous devriez les éviter dans vos nouveaux codes :</p>\n<ul>\n<li><code>UNSAFE_componentWillReceiveProps()</code></li>\n<li><code>UNSAFE_componentWillUpdate()</code></li>\n</ul>\n</blockquote>\n<h3>Traitement récursif sur les enfants</h3>\n<p>Par défaut, lorsqu’il traite les enfants d’un nœud DOM, React parcourt simultanément les deux listes d’enfants et génère une modification chaque fois qu’il y a une différence.</p>\n<p>Par exemple, lors de l’ajout d’un élément à la fin des enfants, la conversion entre les deux arbres fonctionne bien :</p>\n<pre><code>&#x3C;ul>\r\n\t&#x3C;li>first&#x3C;/li>\r\n\t&#x3C;li>second&#x3C;/li>\r\n&#x3C;/ul>\r\n&#x3C;ul>\r\n\t&#x3C;li>first&#x3C;/li>\r\n\t&#x3C;li>second&#x3C;/li>\r\n\t&#x3C;li>third&#x3C;/li>\r\n&#x3C;/ul>\n</code></pre>\n<p>React fera correspondre les deux arbres <code>&#x3C;li>first&#x3C;/li></code>, les deux arbres <code>&#x3C;li>second&#x3C;/li></code>, et insérera l’arbre <code>&#x3C;li>third&#x3C;/li></code>.</p>\n<p>Si vous l’implémentez de façon naïve, l’insertion d’un élément au début aura de moins bonnes performances. Par exemple, la conversion entre ces deux arbres fonctionnera assez mal :</p>\n<pre><code>&#x3C;ul>\r\n\t&#x3C;li>Duke&#x3C;/li>\r\n\t&#x3C;li>Villanova&#x3C;/li>\r\n&#x3C;/ul>\r\n&#x3C;ul>\r\n\t&#x3C;li>Connecticut&#x3C;/li>\r\n\t&#x3C;li>Duke&#x3C;/li>\r\n\t&#x3C;li>Villanova&#x3C;/li>\r\n&#x3C;/ul>\n</code></pre>\n<p>React va modifier chaque enfant plutôt que de réaliser qu’il pouvait garder les sous-arbres <code>&#x3C;li>Duke&#x3C;/li></code> et <code>&#x3C;li>Villanova&#x3C;/li></code> intacts. Cette inefficacité peut être un problème.</p>\n<h3>Clés</h3>\n<p>Afin de résoudre ce problème, React prend en charge l’attribut <code>key</code>. Quand des enfants ont cette clé, React l’utilise pour faire correspondre les enfants de l’arbre d’origine avec les enfants de l’arbre suivant. Par exemple, l’ajout d’une <code>key</code> dans notre exemple inefficace peut rendre la conversion de l’arbre plus efficace :</p>\n<pre><code>&#x3C;ul>\r\n\t&#x3C;li key=\"2015\">Duke&#x3C;/li>\r\n\t&#x3C;li key=\"2016\">Villanova&#x3C;/li>\r\n&#x3C;/ul>\r\n&#x3C;ul>\r\n\t&#x3C;li key=\"2014\">Connecticut&#x3C;/li>\r\n\t&#x3C;li key=\"2015\">Duke&#x3C;/li>\r\n\t&#x3C;li key=\"2016\">Villanova&#x3C;/li>\r\n&#x3C;/ul>\n</code></pre>\n<p>À présent, React sait que l’élément avec la clé <code>'2014'</code> est nouveau, et que les éléments avec les clés <code>'2015'</code> et <code>'2016'</code> ont juste été déplacés.</p>\n<p>En pratique, trouver une clé n’est généralement pas difficile. L’élément que vous allez afficher peut déjà disposer d’un identifiant unique, la clé provenant alors de vos données :</p>\n<pre><code>&#x3C;li key={item.id}>{item.name}&#x3C;/li>\n</code></pre>\n<p>Quand ce n’est pas le cas, vous pouvez ajouter une nouvelle propriété d’identification à votre modèle, ou hacher certaines parties de votre contenu pour générer une clé. La clé n’a besoin d’être unique que parmi ses éléments frères, et non au niveau global.</p>\n<p>En dernier recours, vous pouvez utiliser l’index de l’élément dans un tableau comme clé. Cela fonctionne correctement si les éléments ne sont jamais réordonnés et s’il n’y a ni insertion ni suppression, dans le cas contraire ce serait assez lent.</p>\n<p>Les tris peuvent également causer des problèmes avec les états des composants quand les index sont utilisés comme des clés. Les instances des composants sont mises à jour et réutilisées en fonction de leur clé. Si la clé est un index, déplacer un élément changera sa clé. En conséquence, l’état local des composants utilisés pour des saisies non-contrôlées peut s’emmêler et être mis à jour de manière inattendue.</p>\n<h3>Compromis</h3>\n<p>Rappelez-vous bien que l’algorithme de réconciliation est un détail d’implémentation. React pourrait rafraîchir l’ensemble de l’application à chaque action ; le résultat final serait le même. Pour être clair, rafraîchir dans ce contexte signifie appeler <code>render</code> sur tous les composants, ça ne signifie pas que React les démontera et remontera. Il n’appliquera que les différences obtenues en suivant les règles énoncées dans les sections précédentes.</p>\n<p>Nous affinons régulièrement les heuristiques afin d’accélérer les cas d’usage courants. Dans l’implémentation actuelle, vous pouvez exprimer le fait qu’un sous-arbre a été déplacé parmi ses frères, mais vous ne pouvez pas dire qu’il a été déplacé ailleurs. L’algorithme va refaire le rendu de l’ensemble du sous-arbre.</p>\n<p>Puisque React se repose sur des heuristiques, si les hypothèses derrière celles-ci s’avèrent erronées, ça réduira les performances.</p>\n<ol>\n<li>L’algorithme n’essaiera pas de faire correspondre des sous-arbres de types de composants différents. Si vous êtes amené·e à alterner entre deux types de composants au rendu très similaire, vous devriez peut-être en faire un type unique. En pratique, nous ne considérons pas ça comme un problème.</li>\n<li>Les clés doivent être stables, prévisibles et uniques. Des clés instables (comme celles produites par <code>Math.random()</code>) entraîneront la re-création superflue de nombreuses instances de composants et de nœuds DOM, ce qui peut dégrader les performances et perdre l’état local des composants enfants.</li>\n</ol>\n<hr>\n<h2>Les refs et le DOM</h2>\n<h2>Mode concurrent (expérimental)</h2>\n<h2>Services workers</h2>\n","title":"React"}},"__N_SSG":true}