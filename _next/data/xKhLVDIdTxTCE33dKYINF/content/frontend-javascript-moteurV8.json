{"pageProps":{"content":{"id":"frontend-javascript-moteurV8","path":"frontend/javascript/moteurV8.md","content":"<h1>Moteur v8</h1>\n<p>Moteur de Google, utilisé dans Google Chrome et NodeJS.</p>\n<p>Le moteur est composé de 2 composants principaux :</p>\n<ul>\n<li><strong>Memory Heap</strong> : sert à allouer la mémoire utilisée dans le programme.</li>\n<li><strong>Call Stack (pile d’exécution)</strong> : contient les données des fonctions exécutées par le programme.</li>\n</ul>\n<p>Des <strong>APIs</strong> situées en dehors du moteur sont également à la disposition du développeur.</p>\n<p>La plupart sont souvent utilisées, tel que DOM ou setTimeout, et c’est également ici que nous avons les fameuses <strong>callback queue</strong> ainsi que <strong>event loop</strong>.</p>\n<p>JavaScript étant <strong>single-threaded</strong>, cela veut dire qu’il n’y a qu’une seule pile d’exécution, nous ne pouvons donc faire <strong>qu’une chose à la fois</strong>.</p>\n<p>La pile d’exécution est une structure de données qui enregistre où nous en sommes dans le programme.Si nous entrons dans une fonction, nous la mettons en haut de la pile.Si nous revenons d’une fonction, nous l’enlevons du haut de la pile.</p>\n<p><img src=\"/images/v8-callstack.png\" alt=\"v8-callstack.png\"></p>\n<p>Avoir qu’une seule pile d’exécution peut être pratique, car cela enlève tous les problèmes engendrés par le multithreading.</p>\n<p>Cependant, exécuter un programme sur 1 seul thread a aussi un très gros inconvénient : tout est bloqué quand une tache est longue !</p>\n<p>Alors que se passe-t-il quand une fonction dans la pile d’exécution prend énormément de temps à finir, par exemple, pour un traitement d’images dans votre navigateur ? Tout se bloque, de l’UI de votre page internet jusqu’au navigateur en lui-même.</p>\n<p>En effet, votre navigateur va essayer de rafraîchir la page toute les <strong>1/60 secondes</strong>, et ne peut le faire que si la pile est vide.Si une de vos fonctions prend du temps, c’est la réactivité de votre site web qui en prendra un coup.</p>\n<p>La solution qui nous est proposée (et que vous utilisez sans doute sans modération) est l’asynchrone, avec la <strong>callback queue</strong> et <strong>event loop</strong>.</p>\n<hr>\n<h2><strong>La compilation JavaScript dans les grandes lignes</strong></h2>\n<ol>\n<li><strong>Tokenizing</strong> : décomposer les chaines de caractères en des morceaux, appelés tokens, qui ont un sens pour le compilateur. Prenons le programme suivant : <code>var a = 1</code>; Lors de cette étape, les tokens suivants seront générés : <code>var</code>, <code>a</code>, <code>=</code>, <code>1</code>, <code>;</code>.</li>\n<li><strong>Parsing</strong>: transformer le tableau de tokens généré précédemment en un arbre d’éléments imbriqués, il représente la structure du programme. (AST)</li>\n<li><strong>Code-Generation</strong> : prend l’AST et le transforme en code exécutable.</li>\n</ol>\n<p>Les 3 acteurs:</p>\n<ol>\n<li><strong>Moteur</strong> : il s’occupe de tout, de la compilation à l’exécution de notre programme JS.</li>\n<li><strong>Compilateur</strong> : il s’occupe de la compilation du programme.</li>\n<li><strong>Scope</strong> : collecte et garde une liste des variables déclarées.</li>\n</ol>\n<p>Exemple <code>var a = 1;</code></p>\n<p>Le moteur voit 1 action effectuée au moment de la compilation, et 1 autre, au moment de l’exécution. (En dehors de la tokenisation)</p>\n<p>Décomposons :</p>\n<ul>\n<li>A l’encontre de <code>var a</code>, le Compilateur demande au Scope de regarder si la variable <code>a</code> existe déjà dans le scope en question.Si oui, le Compilateur ne fait rien et continue.Si non, le Compilateur demande à Scope de déclarer la variable <code>a</code> dans le scope en question.</li>\n<li>Le Compilateur génère le code pour <code>a = 1</code> qui sera exécuté par le Moteur plus tard : Le Moteur demandera au Scope si <code>a</code> existe.Si oui, il utilisera cette variable.Si non, une erreur sera renvoyée.Pour résumer, 2 actions peuvent être distinguées lors de l’assignation d’une variable : lors de la compilation, le Compilateur déclare la variable (si elle n’existe pas déjà), et dans un deuxième temps, lors de l’exécution, le Moteur demande la variable à Scope, et lui assigne la valeur.</li>\n</ul>\n<p>On a 2 types de recherche: <strong>LHS</strong> et <strong>RHS</strong> (Left/Right Hand Side).</p>\n<p>RHS: <code>console.log(a);</code> (ici on veut connaitre la valeur a)</p>\n<p>LHS: <code>var a = 1;</code> (ici on n’est pas intéressé par la valeur de <code>a</code>. On veut simplement son conteneur pour lui assigner la valeur 2.)</p>\n<p>Exemple:</p>\n<pre><code>function foo(a) {\r\n    var b = a;\r\n    return a + b;\r\n}\r\nvar c = foo(2);\r\n\n</code></pre>\n<p>Il y a ici 3 <strong>LHS</strong> et 4 <strong>RHS</strong>.</p>\n<p><strong>LHS</strong> :</p>\n<ul>\n<li>c = .. (Récupération du conteneur c)</li>\n<li>a = 2 (Assignement implicite au paramètre de la fonction foo)</li>\n<li>b = .. (Récupération du conteneur b)</li>\n</ul>\n<p><strong>RHS</strong> :</p>\n<ul>\n<li>foo(2) (Récupération de la valeur de c)</li>\n<li>.. = a (Récupération de la valeur de a)</li>\n<li>a + .. (Récupération de la valeur de a)</li>\n<li>.. + b (Récupération de la valeur de b)</li>\n</ul>\n<p>Scope: on disait jusqu’à maintenant que le Scope gardait une liste des variables déclarées. Seulement, il peut y avoir plusieurs Scopes.</p>\n<p>De la même manière que les fonctions, les Scopes sont imbriqués les uns dans les autres.</p>\n<p>Si une variable ne peut pas être trouvée dans le scope immédiat, le Moteur consulte le scope du « dessus ».</p>\n<p>Tant qu’il ne trouve pas la variable, il continue à remonter jusque tout en haut (scope dit « global »).</p>\n<hr>\n<h2>Callback queue + Event loop</h2>\n<p>Le Javascript étant un langage single-thread ****dans un univers du Web où la réactivité est importante, les APIs WEB ****ont pensé à une solution afin d’ajouter une composante asynchrone au langage : callback queue et event loop.</p>\n<p>le moteur de Javascript ne peut pas effectuer plusieurs actions en même temps, mais les APIs WEB ****le peuvent. On peut donc les imaginer comme des threads à part entière.</p>\n<p>Seulement, les ****APIs WEB ne peuvent pas modifier l’ordre d’exécution du code en ajoutant des éléments dans la stack. C’est pour cela que callback queue et event loop ****ont été créées.</p>\n<p>Il s’agit d’une sorte de « file d’attente », qui permet d’effectuer des traitements sans bloquer la pile d’exécution JS.</p>\n<p>Le rôle de event loop est tout simple : déplacer les éléments de la callback queue dans la pile d’exécution JS ****lorsque cette dernière est vide.</p>\n<p><img src=\"/images/v8-eventloop.gif\" alt=\"v8-eventloop.gif\"></p>\n<p>Attention: au même titre que la pile d’exécution JS, il n’existe qu’une seule callback queue. </p>\n<p>Énormément d’appels peuvent délayer tous vos autres traitements asynchrones, ce qui peut donner un effet de ralentissement.</p>\n<p>Exemple:</p>\n<pre><code>console.log(’hi’);\r\n\r\nsetTimeout(function cb(){\r\n    console.log(’there’)\r\n}, 0);\r\n\r\nconsole.log(’JSConfEU’);\n</code></pre>\n<p>On aura ici: hi - JSConfEU - there</p>\n<p>même si le <code>setTimeout</code> se termine immédiatement, <strong>event loop</strong> doit attendre que la stack soit vide avant de pouvoir y mettre les éléments de <strong>callback queue</strong>. <code>there</code>sera donc affiché en dernier, même s’il termine avant le <code>console.log(’JSConfEU’)</code>.</p>\n<p>Outil sympa: <a href=\"http://latentflip.com/loupe/\">http://latentflip.com/loupe/</a></p>\n<p>Sources</p>\n<p><a href=\"https://fr.wikipedia.org/wiki/Moteur_V8\">https://fr.wikipedia.org/wiki/Moteur_V8</a></p>\n<p><a href=\"https://www.axopen.com/blog/2020/08/javascript-langage-compile/\">https://www.axopen.com/blog/2020/08/javascript-callback-queue-event-loop/</a></p>\n","title":"Moteur V8"}},"__N_SSG":true}